<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="styleguide.xsl"?>
<GUIDE title="Google C++ Style Guide">

<p align="right">

Revision 3.231
</p>



<address>Benjy Weinberger<br/> Craig Silverstein<br/> Gregory Eitzmann<br/> Mark Mentovai<br/> Tashana Landray</address>

<OVERVIEW>
<CATEGORY title="Important Note">
  <STYLEPOINT title="Displaying Hidden Details in this Guide">
     <SUMMARY>이 스타일 가이드는 초기에 화면에서 숨겨진 많은 상세한 내용을 포함하고 있습니다. 이들은 왼쪽에서 볼 수 있는 것 같은 삼각형 아이콘으로 마크되어있습니다. 지금 눌러보십시오. 아래에 "야호"가 나타나는 것을 볼 수 있습니다.</SUMMARY>
     <BODY>
       <p>야호! 더 상세한 내용을 얻기 위해서 위치를 확장할 수 있다는 것을 알았습니다. 혹은 이 문서의 위쪽에 "모두 확장하기"도 있습니다.</p>
     </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="Background">
  <p>C++은 Google의 많은 오픈 소스 프로젝트에서 사용되는 주 개발 언어입니다. 모든 C++ 프로그래머가 알고 있듯이, C++ 언어는 많은 강력한 특징들을 가지고 있습니다. 하지만 이 강력함은 버그가 더 쉽게 발생하고 읽고 유지하기 더 어려운 복잡성을 야기합니다.</p>
  <p>이 가이드의 목적은 C++ 코드를 작성하면서 해야할 것과 하지 말아야 할 것을 상세하게 설명해서 이 복잡성을 관리하기 위함입니다. 이러한 규칙들은 코더들이 C++ 언어의 특징을 생산적으로 사용하면서 코드 기반의 관리성을 유지하기 위해서 존재합니다.</p>
  <p><em>스타일</em>(또한 가독성으로 알려진)은 우리가 C++ 코드를 통제하는 관례라고 부르는 것입니다. 스타일이라는 용어는 조금 잘못된 명칭입니다. 왜냐하면 이 관례는 단지 소스 파일 포멧팅 보다는 더 많은 것을 커버하기 때문입니다.</p>
  <p>코드 베이스를 관리 가능하도록 유지하는 하나의 방법은 <em>일관성</em>을 강제하는 것입니다. 어떤 프로그래머가 다른 사람의 코드를 볼 수 있고 빨리 이해할 수 있게 하는 것은 매우 중요합니다. 통일된 스타일을 유지하고 관례를 따른다는 것은 다양한 심볼들이 무엇이고 그것에 대해서 불변인 것이 참인지를 추론하기 위해서 "패턴-매칭"을 더 쉽게 사용할 수 있다는 것을 의미합니다. 공통된 것, 요구되는 관용어법 그리고 패턴을 생성하는 것은 코드를 이해하기 더 쉽게 만듭니다. 일부 경우에는 특정 스타일 규칙에 대해서 좋은 논쟁이 있을지도 모릅니다. 그럼에도 불구하고 우리는 일관성을 유지하기 위해서 규칙을 준수할 것입니다.</p>
  <p>이 가이드가 가리키는 또 다른 이슈는 C++ 특징의 비대함입니다. C++은 많은 진보된 특징을 가진 거대한 언어입니다. 일부 경우에는 특정 특징의 사용을 강제하거나 금지합니다. 코드를 간단하게 유지하고 이러한 특징이 야기할 수 있는 다양한 공통의 에러와 문제를 피하기 위해서 이렇게 합니다. 이 가이드는 이러한 특징들을 나열하고 왜 그들의 사용이 제한되는지를 설명합니다.</p>
  <p>Google에서 개발되는 오픈-소스 프로젝트들은 이 가이드의 요구사항을 따릅니다.</p>
  
  <p>이 가이드는 C++ 튜토리얼이 아님을 명심하십시오: 독자가 언어에 대해서 익숙하다고 가정할 것입니다.</p>
  
</CATEGORY>
</OVERVIEW>

<CATEGORY title="Header Files">
  <p>일반적으로, 모든 <code>.cc</code> 파일은 관련된 <code>.h</code> 파일을 가져야만 합니다. unittest나 단지 <code>main()</code> 함수만을 가지고 있는 작은 <code>.cc</code> 파일들 같은 몇 개의 일반적인 예외도 있습니다.</p>
  <p>헤더 파일의 올바른 사용은 가독성 그리고 코드 사이즈와 코드 성능에 있어서 큰 차이를 가져옵니다.</p>
  <p>다음 규칙들은 헤더 파일 사용시의 다양한 함정들을 통과해서 당신을 안내할 것입니다.</p>

  <STYLEPOINT title="The #define Guard">
    <SUMMARY>모든 헤더 파일들은 여러 번 include되는 것을 막기 위해서 <code>#define</code> 가드를 가져야만 합니다. 심볼 이름의 형식은 <code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code> 여야만 합니다.</SUMMARY>
    <BODY>
      
      <p>유일함을 보장하기 위해서, 프로젝트 소스 트리의 전체 경로에 기반해야만 합니다. 예를 들면, 프로젝트 <code>foo</code>의 파일 <code>foo/src/bar/baz.h</code>는 다음 형태의 가드를 가져야만 합니다:</p>
      <CODE_SNIPPET>
         #ifndef FOO_BAR_BAZ_H_
         #define FOO_BAR_BAZ_H_

         ...

         #endif  // FOO_BAR_BAZ_H_
      </CODE_SNIPPET>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Forward Declarations">
    <SUMMARY>
        You may forward declare ordinary classes in order to avoid
        unnecessary <code>#include</code>s.
    </SUMMARY>
    <BODY>
      <DEFINITION>
          A "forward declaration" is a declaration of a class, function,
          or template without an associated definition. <code>#include</code>
          lines can often be replaced with forward declarations of whatever
          symbols are actually used by the client code.
      </DEFINITION>
      <PROS>
        <ul>
          <li>Unnecessary <code>#include</code>s force the compiler to open
          more files and process more input.</li>
          <li>They can also force your code to be recompiled more often, due
          to changes in the header.</li>
        </ul>
      </PROS>
      <CONS>
        <ul>
          <li>It can be difficult to determine the correct form of a
          forward declaration in the presence of features like templates,
          typedefs, default parameters, and using declarations.</li>
          <li>It can be difficult to determine whether a forward declaration
          or a full <code>#include</code> is needed for a given piece of code,
          particularly when implicit conversion operations are involved. In
          extreme cases, replacing an <code>#include</code> with a forward
          declaration can silently change the meaning of code.</li>
          <li>Forward declaring multiple symbols from a header can be more
          verbose than simply <code>#include</code>ing the header.</li>
          <li>Forward declarations of functions and templates can prevent
          the header owners from making otherwise-compatible changes to
          their APIs; for example, widening a parameter type, or adding
          a template parameter with a default value.</li>
          <li>Forward declaring symbols from namespace <code>std::</code>
          usually yields undefined behavior.</li>
          <li>Structuring code to enable forward declarations (e.g.
          using pointer members instead of object members) can make the
          code slower and more complex.</li>
          <li>The practical efficiency benefits of forward declarations are
          unproven.</li>
        </ul>
      </CONS>
      <DECISION>
        <ul>
          <li>When using a function declared in a header file, always
          <code>#include</code> that header.</li>
          <li>When using a class template, prefer to <code>#include</code> its
          header file.</li>
          <li>When using an ordinary class, relying on a forward declaration
          is OK, but be wary of situations where a forward declaration may
          be insufficient or incorrect; when in doubt, just
          <code>#include</code> the appropriate header.</li>
          <li>Do not replace data members with pointers just to avoid an
          <code>#include</code>.</li>
        </ul>
        Always <code>#include</code> the file that actually provides the
        declarations/definitions you need; do not rely on the symbol being
        brought in transitively via headers not directly included. One
        exception is that <code>myfile.cc</code> may rely on
        <code>#include</code>s and forward declarations from its corresponding
        header file <code>myfile.h</code>.
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Inline Functions">
    <SUMMARY>함수가 작을 때만(10 라인보다 작을 때) 함수를 inline으로 정의하십시오.</SUMMARY>
    <BODY>
      <DEFINITION>컴파일러가 보통의 함수 호출 메커니즘을 통해서 함수를 호출하는 것이 아닌 inline으로 확장하도록 하는 방법으로 함수를 선언할 수 있습니다.</DEFINITION>
      <PROS>함수를 인라인하는 것은 인라인되는 함수가 작으면 작을 수록 더 효과적인 오브젝트 코드를 만들 수 있습니다. 접근자와 수정자, 그리고 성능에 민감한 함수들을 자유롭게 inline 함수로 만드십시오.</PROS>
      <CONS>인라인 함수를 과도하게 사용하는 것은 실제적으로 프로그램을 더 느리게 만듭니다. 함수의 사이즈에 따라서, 해당 함수를 inline하는 것은 코드 사이즈를 증가시키거나 감소시킬 수 있습니다. 매우 큰 함수를 인라인하는 것은 코드 사이즈를 극단적으로 증가시키는 반면에 매우 작은 접근자 함수를 인라인하는 것은 일반적으로 코드 사이즈를 줄입니다. 현대의 프로세서에서는 더 작은 코드는 명령 캐시를 더 잘 사용함으로써 일반적으로 더 빨리 실행됩니다.</CONS>
      <DECISION>
        <p>알맞은 경험은 함수가 10 라인보다 크면 함수를 인라인하지 않는 것입니다. 소멸자의 경우에 암시적으로 멤버와 베이스 클래스의 소멸자를 호출하기 때문에 종종 보이는 것보다 더 크다는 것을 주의하십시오.</p>
        <p>또 다른 유용한 경험은, 루프나 switch 구문과 함께 함수를 인라인하는 것은 전형적으로 효과적이지 않다는 것입니다. (일반적인 경우에, 루프 혹은 switch 구문은 결코 수행되지 않습니다.)</p>
        <p>함수가 인라인으로 선언되었어도 항상 인라인되지는 않는다는 것을 아는 것은 중요합니다; 예를 들면, 가상 함수와 재귀함수는 통상적으로 인라인화되지 않습니다. 일반적으로 재귀 함수는 인라이되어서는 않됩니다. 가상 함수를 인라인으로 만드는 주된 이유는 편리함과 접근자와 수정자처럼 그것의 행동을 문서화하기 위해 클래스에 그것의 정의를 위치시키기 위해서입니다.</p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="The -inl.h Files">
    <SUMMARY>필요한 경우에 복잡한 인라인 함수를 정의하기 위해서 파일 이름이 <code>-inl.h</code>로 끝나는 파일을 사용할지도 모릅니다.</SUMMARY>
    <BODY>
      <p>호출하는 쪽에서 컴파일러가 inline하기 위해 사용할 정의를 가지기 위해서, inline 함수는 헤더파일에 있어야 할 필요가 있습니다. 그러나 정확하게는 구현 코드는 <code>.cc</code> 파일에 속합니다. 그리고 가독성과 성능의 이점이 없다면, 많은 실제적인 코드들이 <code>.h</code> 파일에 있기를 원하지 않습니다.</p>
      <p>만약 인라인 함수의 정의가 매우 짧다면, <code>.h</code> 파일에 코드를 넣어야만 합니다. 예를 들면, 접근자와 수정자는 확실히 클래스 정의내에 있어야만 합니다. 더 복잡한 인라인 함수는 구현과 호출시의 편리함을 위해서 <code>.h</code> 파일에 들어갈 수 있습니다. 하지만 이게 <code>.h</code> 파일을 비대하게 만든다면, 대신에 별도의 <code>-inl.h</code> 파일에 코드를 추가할 수 있습니다. 이것이 필요한 곳에서 구현을 include할 수 있게 하면서, 클래스 정의로부터 구현을 분리해 줍니다.</p>
      <p><code>-inl.h</code> 파일의 다른 사용처는 함수 템플릿의 정의를 위해서 입니다. 이것은 템플릿 정의들을 읽기 쉽게 유지시키기 위해서 사용될 수 있습니다.</p>
      <p><code>-inl.h</code> 파일이 다른 헤더 파일들처럼 <a href="#The__define_Guard"><code>#define</code> 가드</a>를 필요로 한다는 것을 잊지 마십시오.</p>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Parameter Ordering">
    <SUMMARY>함수를 정의할 때, 파라메터의 순서는: 입력들, 그리고 출력들입니다.</SUMMARY>
    <BODY>
      <p>C/C++의 파라메터는 함수의 입력이기도 하고 함수로부터의 출력이기도 하고, 혹은 둘 다 이기도 합니다. 입력 파라메터는 일반적으로 값이거나 <code>const</code> 레퍼런스입니다. 반면에 출력과 입/출력 파라메터는 <code>const</code>가 아닌 포인터일 것입니다. 함수 파라메터의 순서를 정렬할 때, 입력 전용의 파라메터를 다른 출력 파라메터 이전에 넣으십시오. 특히 새로운 파라메터를 단지 새로운 파라메터기 때문에 함수 파라메터의 끝에 추가하지 마십시오. 새로운 입력 전용의 파라메터는 출력 파라메터 이전에 넣으십시오.</p>
      <p>이것은 강력한 규칙은 아닙니다. 일관성을 흐트리는 입력과 출력 둘 다의(종종 클래스/구조체) 파라메터는 이 규칙을 어길 것 입니다.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Names and Order of Includes">
    <SUMMARY>가독성과 숨겨진 의존성을 피하기 위해서 표준 순서를 사용하십시오: C 라이브러리, C++ 라이브러리, 다른 라이브러리의 <code>.h</code>, 당신의 프로젝트의 <code>.h</code>.</SUMMARY>
    <BODY>
      <p>프로젝트의 모든 헤더 파일들은 UNIX 디렉토리 쇼트컷인 <code>.</code> (현재 디렉토리) 혹은 <code>..</code> (부모 디렉토리) 없는 프로젝트 소스 디렉토리의 내림차순으로 리스트되어야만 합니다. 예를 들면, <code>google-awesome-project/src/base/logging.h</code>는 다음과 같이 include 되어야만 합니다.</p>
      <CODE_SNIPPET>
        #include "base/logging.h"
      </CODE_SNIPPET>
      <p>주된 목적이 <code><var>dir2/foo2</var>.h</code>에 대한 구현이나 스텁의 테스트인 <code><var>dir/foo</var>.cc</code> 혹은 <code><var>dir/foo_test</var>.cc</code>에서의 include 순서는 다음과 같습니다.:</p>
      <ol>
        <li> <code><var>dir2/foo2</var>.h</code> (preferred location
          — see details below).</li>
        <li>C 시스템 파일들.</li>
        <li>C++ 시스템 파일들.</li>
        <li>다른 라이브러리들의 <code>.h</code> 파일들.</li>
        <li>프로젝트의 <code>.h</code> 파일들.</li>
      </ol>
      <p>
        With the preferred ordering, if <code><var>dir2/foo2</var>.h</code>
        omits any necessary includes, the build of
        <code><var>dir/foo</var>.cc</code> or
        <code><var>dir/foo</var>_test.cc</code> will break.
        Thus, this rule ensures that build breaks show up first
        for the people working on these files, not for innocent people
        in other packages.
      </p>
      <p><code><var>dir/foo</var>.cc</code>와 <code><var>dir2/foo2</var>.h</code> 파일은 종종 같은 디렉토리에 있게 됩니다. (예를 들면 <code>base/basictypes_test.cc</code>와 <code>base/basictypes.h</code>), 그러나 역시 다른 디렉토리에 있을 수도 있습니다.</p>
      
      <p>
        Within each section the includes should be ordered alphabetically.
        Note that older code might not conform to this rule and should be
        fixed when convenient.
      </p>
      <p>예를 들면, <code>google-awesome-project/src/foo/internal/fooserver.cc</code>에서 include는 다음과 같이 보일 것입니다:</p>
      <CODE_SNIPPET>
        #include "foo/public/fooserver.h"  // Preferred location.

        #include &lt;sys/types.h&gt;
        #include &lt;unistd.h&gt;
        #include &lt;hash_map&gt;
        #include &lt;vector&gt;

        #include "base/basictypes.h"
        #include "base/commandlineflags.h"
        #include "foo/public/bar.h"
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Scoping">
  <STYLEPOINT title="Namespaces">
    <SUMMARY><code>.cc</code> 파일에서 이름없는 namespace는 추천됩니다. 이름있는 namespace에서는, 프로젝트와 그리고 가능한한 그것의 경로에 기반한 이름을 선택하십시오. <SYNTAX>using-directive</SYNTAX>를 사용하지 마십시오.</SUMMARY>
    <BODY>
      <DEFINITION>namespace는 구별되고 이름있는 공간으로 전역 공간을 구분합니다. 그리고 전역 공간에서 이름의 충돌을 막기 위해서 유용합니다.</DEFINITION>
      <PROS>
        <p>네임스페이스는 클래스에 의해서 제공되는 (계층적인)이름 공간(axis)에 덧붙여서 (계층적인)이름 공간(axis)을 제공합니다.</p>
        <p>예를 들면, 두개의 다른 프로젝트가 전역 공간에서 클래스 <code>Foo</code>를 가진다면, 이 심볼들은 컴파일 타임 혹은 런타임에 이름이 충돌할지도 모릅니다. 만약 각 프로젝트들이 코드를 네임스페이스에 넣었다면, 이제 <code>project1::Foo</code>와 <code>project2::Foo</code>는 충돌을 일으키지 않는 구별되는 심볼이 됩니다.</p>
      </PROS>
      <CONS>
        <p>네임스페이스는 혼란스러울 수 있습니다. 왜냐하면 클래스가 제공하는 (계층적인) 이름 공간(axis)에 덧붙여서 추가적인 (계층적인) 이름 공간(axis)를 제공하기 때문입니다.</p>
        <p>
          Use of unnamed namespaces in header files can easily cause
          violations of the C++ One Definition Rule (ODR).
        </p>
      </CONS>
      <DECISION>
        <p>
          Use namespaces according to the policy described below.
          Terminate namespaces with comments as shown in the given examples.
        </p>

        <SUBSECTION title="Unnamed Namespaces">
          <ul>
            <li>이름없는 네임스페이스는 실행시간에 이름 충돌을 피하기 위해서 허용되며, <code>.cc</code> 파일에서는 심지어 권장됩니다.: <CODE_SNIPPET>
                   namespace {                           // This is in a .cc file.

                   // The content of a namespace is not indented
                   enum { kUnused, kEOF, kError };       // Commonly used tokens.
                   bool AtEof() { return pos_ == kEOF; }  // Uses our namespace's EOF.

                   }  // namespace
                 </CODE_SNIPPET><p>
                   However, file-scope declarations that are
                   associated with a particular class may be declared
                   in that class as types, static data members or
                   static member functions rather than as members of
                   an unnamed namespace.
                 </p></li>
            <li><code>.h</code> 파일에서 이름없는 네임스페이스를 사용하지 마십시오.</li>
          </ul>
        </SUBSECTION>

        <SUBSECTION title="Named Namespaces">
          <p>이름 있는 네임스페이스는 다음과 같이 사용되어야만 합니다.:</p>
          <ul>
            <li>네임스페이스는 include, <a href="http://google-gflags.googlecode.com/">gflags</a> 정의/선언, 그리고 다른 네임스페이스의 클래스의 전방선언후에 전체 소스 파일을 감쌉니다. <CODE_SNIPPET>
                   // In the .h file
                   namespace mynamespace {

                   // All declarations are within the namespace scope.
                   // Notice the lack of indentation.
                   class MyClass {
                    public:
                     ...
                     void Foo();
                   };

                   }  // namespace mynamespace
                 </CODE_SNIPPET><CODE_SNIPPET>
                   // In the .cc file
                   namespace mynamespace {

                   // Definition of functions is within scope of the namespace.
                   void MyClass::Foo() {
                     ...
                   }

                   }  // namespace mynamespace
                 </CODE_SNIPPET><p>전형적인 <code>.cc</code> 파일은 다른 네임스페이스에 있는 클래스를 참조하는데 필요한 것을 포함하므로 상세 내용은 더 복잡할 수 있습니다.</p><CODE_SNIPPET>
                   #include "a.h"

                   DEFINE_bool(someflag, false, "dummy flag");

                   class C;  // Forward declaration of class C in the global namespace.
                   namespace a { class A; }  // Forward declaration of a::A.

                   namespace b {

                   ...code for b...         // Code goes against the left margin.

                   }  // namespace b
                 </CODE_SNIPPET></li>

            

            <li><code>std</code> 네임스페이스에는 아무것도 선언하지 않으며, 심지어 표준 라이브러리 클래스에 대한 전방 선언일지라도 마찬가지입니다. <code>std</code> 네임스페이스에 요소를 선언하는 것은 정의되지 않은 동작입니다. 즉 이식성이 없습니다. 표준 라이브러리에 있는 요소를 선언하려면 적절한 헤더 파일을 include 하십시오.</li>

            <li>네임스페이스에서 모든 이름을 사용하기 위해서 <SYNTAX>using-directive</SYNTAX>를 사용하지 말아야 합니다. <BAD_CODE_SNIPPET>
                   // Forbidden -- This pollutes the namespace.
                   using namespace foo;
                 </BAD_CODE_SNIPPET></li>

            <li><SYNTAX>using-declaration</SYNTAX>은 <code>.cc</code> 파일, <code>.h</code> 파일에 있는 함수, 메소드 또는 클래스 등 어디서든 사용해도 좋습니다.</li>

            <li>네임스페이스 별칭은 <code>.cc</code> 파일내 어디든지에서, 전체 <code>.h</code> 파일을 감싸는 이름있는 네임스페이스내 어디든지에서, 그리고 함수와 메소드내 어디든지에서 사용할 수 있습니다.<CODE_SNIPPET>
                   // Shorten access to some commonly used names in .cc files.
                   namespace fbz = ::foo::bar::baz;

                   // Shorten access to some commonly used names (in a .h file).
                   namespace librarian {
                   // The following alias is available to all files including
                   // this header (in namespace librarian):
                   // alias names should therefore be chosen consistently
                   // within a project.
                   namespace pd_s = ::pipeline_diagnostics::sidetable;

                   inline void my_inline_function() {
                     // namespace alias local to a function (or method).
                     namespace fbz = ::foo::bar::baz;
                     ...
                   }
                   }  // namespace librarian
                 </CODE_SNIPPET><p>.h 파일에서의 별칭은 그 파일을 #include하는 모든 이들에게 보여집니다. 따라서 공용 API는 가능한한 작게 유지한다는 일반적인 목적의 일환으로, 공용 헤더 파일(프로젝트 외부에서 이용할 수 있는)과 그 파일을 간접적으로 #include하는 헤더 파일들은 별칭을 정의하는 것을 피해야만 합니다.</p></li>
          </ul>
        </SUBSECTION>

        

        

        
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Nested Classes">
    <SUMMARY>public 중첩 클래스가 인터페이스의 일부분 일 때, 그것을 사용할지라도, 전역 공간외에서 선언을 유지하기 위해서는 <a HREF="#Namespaces">namespace</a>를 고려하십시오.</SUMMARY>
    <BODY>
      <DEFINITION>클래스는 클래스내에 다른 클래스를 정의할 수 있습니다.; 이것은 또한 <SYNTAX>member class</SYNTAX>라고 불립니다. <CODE_SNIPPET>
          class Foo {

           private:
            // Bar is a member class, nested within Foo.
            class Bar {
              ...
            };

          };
        </CODE_SNIPPET></DEFINITION>
      <PROS>이것은 중첩된(혹은 멤버) 클래스가 그것을 포함하고 있는 클래스 내부에서만 사용된다는 점에서 유용합니다; 즉, 중첩된 클래스 이름을 바깥에 드러내지 않으면서 그것을 포함하는 클래스 범위 안에 그 멤버를 둘 수 있습니다. 중첩된 클래스 정의를 그것을 포함하는 클래스 선언안에 두지 않기 위해서 중첩된 클래스를 그것을 포함하는 클래스 안에서 전방 선언한 후에 <code>.cc</code> 파일에서 정의할 수 있습니다. 흔히 중첩 클래스 정의는 구현 관련해서만 의미가 있기 때문입니다.</PROS>
      <CONS>중첩된 클래스는 그것을 포함하는 클래스 정의 안에서만 전방 선언할 수 있습니다. 그러므로, <code>Foo::Bar*</code> 포인터를 다루는 다른 헤더 파일에서는 <code>Foo</code>에 대한 전체 클래스 선언을 include 해야만 합니다.</CONS>
      <DECISION>중첩된 클래스가 실제 인터페이스의 일부가 아니라면 public으로 만들지 마십시오. 예를 들면, 몇개의 메소드에 대해서 옵션의 모음을 유지하는 클래스의 경우입니다.</DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Nonmember, Static Member, and Global Functions">
    <SUMMARY>네임스페이스내의 비-멤버 함수나 전역 함수로서는 static 멤버 함수를 선호하십시오. 완전한 전역 함수는 덜 사용하십시오.</SUMMARY>
    <BODY>
      <PROS>비-멤버 함수와 static 멤버 함수는 일부 상황에서 유용할 수 있습니다. 전역 이름 공간을 오염시키는 것을 피하기 위해서 namespace내에 비-멤버함수를 넣으십시오.</PROS>
      <CONS>비-멤버 함수와 static 멤버 함수가 특별히 외부 리소스에 접근하거나 중요한 의존성을 가진다면, 새로운 클래스의 멤버로 만드는 것이 더 합당할지도 모릅니다.</CONS>
      <DECISION>
        <p>때때로 함수를 클래스 인터페이스의 내부에 정의하지 않는 것이 유용하거나 심지어 필요한 경우도 있습니다. 그러한 함수는 static 멤버거나 비-멤버 함수가 될 수 있습니다. 비-멤버 함수는 외부 변수에 의존해서는 안되고 거의 항상 namespace내에 존재해야만 합니다. 단지 static 데이타를 공유하지 않는 static 멤버 함수들을 묶기 위해서 클래스를 생성하기 보다는, 대신에 <a href="#Namespaces">namespaces</a>를 사용하십시오.</p>
        <p>프로덕션 클래스로써 같은 컴파일 단위에 정의된 함수들은 다른 컴파일 단위에서 직접적으로 호출될 때, 불필요한 결합과 링크-타임 의존성이 생길 수 있습니다. 특히 정적 멤버 함수는 더욱 그렇게 되기 쉽습니다. 새로운 클래스로 분리하거나, 별도의 라이브러리내의 네임스페이스내로 그런 함수를 옮기는 것을 고려하십시오.</p>
        <p>비멤버 함수를 정의해야 하고 <code>.cc</code> 파일에서만 필요하다면, 범위를 제한하기 위해서 이름없는 <a HREF="#Namespaces">namespace</a>나 <code>static</code> 링키지(예를 들면, <code>static int Foo() {...}</code>)를 사용하십시오.</p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Local Variables">
    <SUMMARY>함수의 변수는 가능한한 작은 범위에 위치시키십시오. 그리고 선언시에 값을 초기화사키십시오.</SUMMARY>
    <BODY>
      <p>C++은 함수내 어디에서든 변수를 선언할 수 있게 합니다. 가능한한 지역 범위내에서 그리고 가능한한 처음으로 사용되는 곳에 가깝게 선언하도록 하십시오. 이것은 코드를 읽는 사람이 선언한 곳을 더 쉽게 찾고, 변수가 어떤 타입인지, 무엇으로 초기화했는지를 쉽게 알 수 있게 합니다. 특히 선언과 대입 대신에 초기화가 사용되어야만 합니다. 예를 들면.</p>
      <BAD_CODE_SNIPPET>
        int i;
        i = f();      // Bad -- initialization separate from declaration.
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        int j = g();  // Good -- declaration has initialization.
      </CODE_SNIPPET>
      <p>gcc에서는 <code>for (int i = 0; i &lt; 10; ++i)</code> 를 올바르게 구현합니다 (<code>i</code>의 범위는 단지 <code>for</code> 루프의 범위입니다.). 그래서 같은 범위의 다른 <code>for</code> 루프에서 <code>i</code>를 다시 사용할 수 있습니다. 또한 <code>if</code>와 <code>while</code> 구문에서도 범위 선언은 마찬가지입니다. 예를 들면.</p>
      <CODE_SNIPPET>
        while (const char* p = strchr(str, '/')) str = p + 1;
      </CODE_SNIPPET>
      <p>한가지 단서가 있습니다: 만약 변수가 객체라면, 범위에 들어갈 때마다 생성자가 호출되고 생성됩니다. 그리고 범위를 벗어날 때마다 소멸자가 호출됩니다.</p>
      <BAD_CODE_SNIPPET>
        // Inefficient implementation:
        for (int i = 0; i &lt; 1000000; ++i) {
          Foo f;  // My ctor and dtor get called 1000000 times each.
          f.DoSomething(i);
        }
      </BAD_CODE_SNIPPET>
      <p>루프에서 사용되는 그러한 변수는 루프 바깥에서 선언하는 것이 더 효과적입니다.</p>
      <CODE_SNIPPET>
        Foo f;  // My ctor and dtor get called once each.
        for (int i = 0; i &lt; 1000000; ++i) {
          f.DoSomething(i);
        }
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Static and Global Variables">
    <SUMMARY>클래스 타입의 Static 혹은 global 변수는 금지되어 있습니다: 이것은 생성과 소멸의 불확실한 순서 때문에 찾기 어려운 버그를 야기합니다.</SUMMARY>
    <BODY>
      <p>전역 변수, 정적 변수, 정적 클래스 멤버 변수, 그리고 함수의 정적 변수를 포함해서 정적 저장 공간을 가지는 객체는 Plain Old Data(POD)여야만 합니다. 즉 int, char, float, 포인터, 혹은 POD의 배열이나 구조체여야만 합니다.</p>
      <p>정적 변수에 대한 클래스 생성자와 초기화 식을 호출하는 순서는 C++에서 단지 부분적으로만 정의되어 있습니다. 심지어 빌드할 때마다 바뀔 수도 있습니다. 따라서 찾아내기 힘든 버그를 야기할 수 있습니다. 그러므로 클래스 타입의 전역 변수의 사용을 금지하는 것에 덧붙여서 함수(getenv()나 getpid()처럼)가 다른 전역변수에 의존한다면, 해당 함수의 결과를 가지고 초기화되는 정적 POD 변수의 사용을 허용하지 않습니다.</p>
      <p>소멸자의 호출 순서는 생성자가 호출되는 순서와 반대로 정의됩니다. 하지만 생성자의 순서가 정해지지 않았기 때문에, 소멸자의 순서도 마찬가지입니다. 예를 들면, 프로그램이 종료될 때 정적 변수는 소멸한 상태일 수 있지만 코드는 여전히 다른 스레드에서 실행중이어서 그 변수에 접근하다가 실패할 수도 있습니다. 혹은 정적 'string' 변수에 대한 소멸자가 해당 string의 참조자를 포함하는 다른 변수에 대한 소멸자 전에 호출될지도 모릅니다.</p>
      <p>이 때문에 POD 데이타를 포함한 정적 변수만을 허용합니다. 이 규칙은 <code>vector</code>(대신 C 배열을 사용하십시오)나 <code>string</code>(<code>const char []</code>를 사용하십시오)의 사용을 완전히 허용하지 않습니다.</p>
      
      <p>만약 클래스 타입의 정적 혹은 전역 변수가 필요하다면, main() 함수나 pthread_once() 함수에서 초기화하는 포인터(절대 free되지는 않는)를 고려해 보십시오. 이것은 "smart" 포인터가 아닌 기본형(raw) 포인터여야만 하는 것을 주의하십시오. 왜냐하면 smart 포인터의 소멸자는 우리가 피하려고 했던 소멸자-순서 문제를 가지고 있기 때문입니다.</p>
      
      
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Classes">클래스는 C++에서 코드의 기본적인 단위입니다. 당연히, 우리는 클래스를 폭넓게 사용합니다. 이 섹션은 클래스를 작성할 때 해야만 하는 것과 해서는 안되는 것들을 리스트합니다. <STYLEPOINT title="Doing Work in Constructors"><SUMMARY>
      Avoid doing complex initialization in constructors (in particular,
      initialization that can fail or that requires virtual method calls).
    </SUMMARY><BODY><DEFINITION>생성자 몸체에서 초기화를 수행하는 것은 가능합니다.</DEFINITION><PROS>타이핑하기 편리합니다. 클래스가 초기화되었는지 아닌지를 걱정할 필요가 없습니다.</PROS><CONS>생성자에서 작업을 할 때의 문제점들은: <ul><li>생성자에 대해서 예외를 사용하는 것을 제외하고는(<a HREF="#Exceptions">금지된</a>), 에러를 발생시킬 쉬운 방법이 없습니다.</li><li>작업이 실패하면, 이제 초기화 코드가 실패한 객체를 가지게 됩니다. 그래서 그것은 불명확한 상태가 될 지도 모릅니다.</li><li>작업이 가상 함수를 호출한다면, 파생 클래스의 구현을 호출하지 못할 것입니다. 심지어 현재는 파생시키지 않았더라도, 나중에 클래스를 수정하게 되면, 모르는 사이에 이런 문제가 생겨서 매우 혼란스러울수 있습니다.</li><li>다른 사람이 이 타입의 전역 변수를 생성한다면(규칙에는 위배되지만, 여전히 존재하는), 생성자 코드는 <code>main()</code> 전에 호출될 것이고, 생성자 코드내에서 암시적으로 가정하고 있던 어떤 것을 깨뜨릴 가능성이 있습니다. 예를 들면 <a href="http://google-gflags.googlecode.com/">gflags</a>는 아직 초기화되지 않았을 것입니다.</li></ul></CONS><DECISION>
        Constructors should never call virtual functions or attempt to raise
        non-fatal failures. If your object requires non-trivial
        initialization, consider using  a factory function or <code>Init()</code> method.
      </DECISION></BODY></STYLEPOINT><STYLEPOINT title="Default Constructors"><SUMMARY>클래스가 멤버 변수를 정의하고 어떤 다른 생성자도 없다면 기본 생성자를 정의해야만 합니다. 그렇지 않으면 컴파일러가 기본 생성자를 잘못되게 만들 것입니다.</SUMMARY><BODY><DEFINITION>기본 생성자는 아규먼트 없이 클래스 오브젝트를 <code>new</code>할 때, 호출됩니다. (배열에 대해서) <code>new[]</code>를 호출할 때도 기본 생성자는 항상 호출됩니다.</DEFINITION><PROS>기본적으로 "불가능한" 값으로 초기화 시키는 것은 디버깅을 윌씬 더 쉽게 만듭니다.</PROS><CONS>코드를 작성해야만 합니다.</CONS><DECISION><p>클래스가 멤버 변수를 정의하고 다른 생성자가 없다면, 기본 생성자(파라메트를 가지지 않는)를 정의해야만 합니다. 기본 생성자는 되도록이면 객체의 내부 상태를 일관되고 유효하도록 초기화해야 합니다.</p><p>기본 생성자를 정의해야하는 이유는 다른 생성자가 없고, 기본 생성자를 정의하지 않았다면, 컴파일러가 기본 생성자를 생성할 것이기 때문입니다. 컴파일러가 생성하는 생성자는 객체를 올바르게 초기화하지 않을지도 모릅니다.</p><p>클래스가 존재하는 클래스로부터 상속되었지만 새로운 멤버 변수를 추가하지 않았다면, 기본 생성자를 가질 필요는 없습니다.</p></DECISION></BODY></STYLEPOINT><STYLEPOINT title="Explicit Constructors"><SUMMARY>하나의 아규먼트를 가진 생성자에 대해서 C++ 키워드 <code>explicit</code>을 사용하십시오.</SUMMARY><BODY><DEFINITION>일반적으로, 생성자가 하나의 아규먼트를 가진다면, 그 생성자는 변환으로 사용될 수 있습니다. 예를 들면 <code>Foo::Foo(string name)</code>를 정의하고 <code>Foo</code>를 기대하는 함수에 string을 전달한다면, string을 <code>Foo</code>로 변환하기 위해서 생성자가 호출될 것이며 함수에 <code>Foo</code>를 전달할 것입니다. 이것은 편리할 수 있습니다. 하지만 변환되어 의도하지 않는 새로운 객체가 생성될 때 문제의 원인이 되기도 합니다. 생성자를 <code>explicit</code>로 선언하는 것은 변환이 암시적으로 발생하는 것을 막아줍니다.</DEFINITION><PROS>원하지 않는 변환을 피합니다.</PROS><CONS>없습니다.</CONS><DECISION><p>하나의 아규먼트를 가진 모든 생성자는 explicit으로 선언되어야 합니다. 클래스 정의에서 하나의 아규먼트를 가진 생성자의 앞에 다음처럼 항상 <code>explicit</code>를 넣으십시오: <code>explicit Foo(string name);</code></p><p>복사 생성자는 예외인데, 드물지만 사용을 허락할 때는 <code>explicit</code>으로 선언하지 않아야 합니다. 다른 클래스를 투명하게 감쌀 의도의 클래스들도 예외입니다. 그러한 예외들은 명확하게 주석으로 설명해야 합니다.</p></DECISION></BODY></STYLEPOINT><STYLEPOINT title="Copy Constructors"><SUMMARY>필요한 경우에만 복사 생성자와 대입 연산자를 제공하십시오. 다른 경우라면 <code>DISALLOW_COPY_AND_ASSIGN</code>로 그것들은 비활성화 하십시오.</SUMMARY><BODY><DEFINITION>복사 생성자와 대입 연산자는 객체의 사본을 생성하기 위해서 사용됩니다. 복사 생성자는 특정 상황에서 컴파일러에 의해서 암시적으로 호출됩니다. 예를 들면 값으로 객체가 전달될 경우입니다.</DEFINITION><PROS>복사 생성자는 객체를 복사하기 쉽게 합니다. STL 컨테이너에서는 복사할 수 있고 대입할 수 있는 것을 필요로 합니다. 복사 생성자는 차선책인 <code>CopyFrom()</code>-스타일 보다 더 효과적일 수 있습니다. 복사하면서 생성하고 어떤 상황에서는 컴파일러에서 이 과정을 건너 뛸 수 있으며, 힙을 할당하지 않도록 하는 것도 더 쉽기 때문이다.</PROS><CONS>C++에서 객체를 암시적으로 복사하는 것은 많은 버그와 성능 문제를 만들 수 있습니다. 또한 가독성을 떨어뜨리고 참조에 비해 값으로 전달할 때 어떤 객체를 전달하는지 추적하기 어려워, 객체가 어디서 바뀌는지 알기 어렵습니다.</CONS><DECISION><p>복사할 수 있어야 하는 클래스는 적습니다. 대부분은 복사 생성자와 대입 연산자가 없어도 됩니다. 많은 경우에 포인터나 참조는 값을 복사하는 것 만큼 잘 동작하고 성능도 더욱 좋습니다. 예를 들어 함수 매개변수를 값 대신 참조나 포인터로 전달 할 수 있고 STL 컨테이너에 객체 대신 포인터를 저장할 수도 있습니다.</p><p>클래스를 복사할 수 있어야 한다면 복사 생성자보다 <code>CopyFrom()</code>이나 <code>Clone()</code>과 같은 복사 메소드를 제공하는게 더 좋습니다. 이런 메소드는 암시적으로 호출할 수 없기 때문입니다. (성능 문제나 클래스를 STL 컨테이너에 값으로 저장해야 하는 등의 이유로) 복사 메소드가 적합하지 않으면 복사 생성자와 대입 연산자 모두를 제공합니다.</p><p>복사 생성자나 대입 연산자가 필요없으면 명시적으로 비활성해야 합니다. 그렇게 하려면 클래스의 <code>private:</code> 섹션에 더미의 복사 생성자와 대입 연산자 선언을 추가하고 정의는 하지 않도록 합니다.(그래서 사용하려고 시도하면 링크에러가 발생하도록 합니다.)</p><p>편리하게, <code>DISALLOW_COPY_AND_ASSIGN</code> 사용할 수 있습니다:</p><CODE_SNIPPET>
          // A macro to disallow the copy constructor and operator= functions
          // This should be used in the private: declarations for a class
          #define DISALLOW_COPY_AND_ASSIGN(TypeName) \
            TypeName(const TypeName&amp;);               \
            void operator=(const TypeName&amp;)
        </CODE_SNIPPET><p>그런 다음, <code>class Foo</code>에서:</p><CODE_SNIPPET>
          class Foo {
           public:
            Foo(int f);
            ~Foo();

           private:
            DISALLOW_COPY_AND_ASSIGN(Foo);
          };
        </CODE_SNIPPET><p>
        </p></DECISION></BODY></STYLEPOINT><STYLEPOINT title="Structs vs. Classes"><SUMMARY>데이타를 전달하는 passive 객체에 대해서만 <code>struct</code>를 사용하십시오; 그외의 모든 경우에는 <code>class</code> 입니다.</SUMMARY><BODY><p>C++에서 <code>struct</code>와 <code>class</code> 키워드는 거의 동일하게 동작합니다. 따라서 각 키워드에 내포된 의미를 추가해서 정의하는 데이터 타입에 따라 적절한 키워드를 사용합니다.</p><p><code>structs</code>는 데이터를 나르는 수동 객체에 사용하고, 관련 상수는 있을 수 있으나 데이터 멤버를 접근하거나 설정하는 것 외에 다른 기능은 없어야 합니다. 필드에 접근하거나 설정할 때는 메소드를 호출하지 말고 해당 필드에 직접 접근해 처리합니다. 메소드에서는 행위를 제공하지 않아야 하고, 생성자, 소멸자, <code>Initialize()</code>, <code>Reset()</code>, <code>Validate()</code>등을 예로 든 것처럼 데이터 멤버를 설정하는 데만 써야 합니다.</p><p>더 많은 기능이 필요하면 <code>class</code>가 더 적절합니다. 무엇을 써야 할지 모르겠으면 <code>class</code>로 합니다.</p><p>STL의 일관성에 대해서, 함수자와 특성(trait)에 대해 <code>class</code> 대신 <code>struct</code>를 쓸 수 있습니다.</p><p>구조체와 클래스에서의 멤버 변수는 <a HREF="#Variable_Names">different naming rules</a>를 가지는 것을 주의하십시오.</p></BODY></STYLEPOINT><STYLEPOINT title="Inheritance"><SUMMARY>합성(Composition)이 상속보다 종종 더 좋습니다. 상속을 사용할 때는, <code>public</code>으로 만드십시오.</SUMMARY><BODY><DEFINITION>하위 클래스에서 기초 클래스를 상속하면 부모인 기초 클래스에서 정의한 모든 데이터와 연산에 대한 정의를 하위 클래스에서 포함합니다. 실제로 C++에서 상속은 두 가지 주요한 방법으로 하는데, 실제 코드를 자식에서 상속하는 구현 상속과 메소드 이름만 상속하는 <A HREF="#Interfaces">인터페이스 상속</A> 입니다.</DEFINITION><PROS>구현 상속은 기존 타입을 구체화 하듯이, 기초 클래스 코드를 재사용해 코드 크기를 줄입니다. 상속은 컴파일 시점 선언이므로 컴파일러에서 연산을 이해하고 오류를 발견할 수 있습니다. 인터페이스 상속은 클래스에서 특정 API를 드러내도록 프로그램적으로 강제하는데 사용할 수 있습니다. 이 역시도 API 중 필요한 메소드를 클래스에서 정의하지 않으면 컴파일러에서 오류를 찾을 수 있습니다.</PROS><CONS>구현 상속에서는 하위 클래스를 구현한 코드가 기초와 하위 클래스에 퍼져있으므로 구현 내용을 이해하기 더 어려울 수 있습니다. 함수가 가상이 아니면 하위 클래스에서 재정의할 수 없으므로 구현 내용을 하위 클래스에서 바꿀 수 없습니다. The base class may also define some data members, so that specifies physical layout of the base class.</CONS><DECISION><p>모든 상속은 <code>public</code>이어야 합니다. private 상속을 하려면 그 대신 기초 클래스 인스턴스를 멤버로 포함해야 합니다.</p><p>구현 상속을 지나치게 사용하지 말아야 합니다. 종종 포함이 더 낫습니다. 상속은 "is-a" 관계일 때로 한정해 사용하도록 합니다. 즉 <code>Bar</code>는 <code>Foo</code>의 "한 종류이다(is a kind of)"라고 말할 수 있으면 <code>Bar</code>가 <code>Foo</code>를 상속한 것이다.</p><p>필요하면 소멸자를 virtual로 합니다. 클래스에 가상 메소드가 있으면 소멸자는 가상이어야 합니다.</p><p><code>protected</code>는 하위 클래스에서 접근할 수도 있는 멤버 함수로 제한해 사용합니다. <a href="#Access_Control">데이타 멤버는 private여야만 합니다.</a>.</p><p>상속한 가상 함수를 파생 클래스에서 재정의할 때는 명시적으로 <code>virtual</code>로 선언하십시오. 이유는 <code>virtual</code>을 생략하면 해당 클래스의 모든 조상을 확인해야 해당 함수가 가상인지 아닌지 알 수 있기 때문입니다.</p></DECISION></BODY></STYLEPOINT><STYLEPOINT title="Multiple Inheritance"><SUMMARY>매우 드문 경우에는 다중 상속이 실제로 유용합니다. 베이스 클래스중 적어도 하나가 구현을 가지는 경우에만 다중 상속을 허용합니다.; 모든 다른 베이스 클래스는 <code>Interface</code> 서픽스로 태그된 <A HREF="#Interfaces">pure interface</A> 클래스여야만 합니다.</SUMMARY><BODY><DEFINITION>다중 상속으로 하위 클래스에서는 기초 클래스를 하나 이상 상속할 수 있습니다. 여기서는 <em>pure interfaces</em>인 기초 클래스와 <em>implementation</em>이 있는 것을 구분합니다.</DEFINITION><PROS>다중 구현 상속은 단일 상속보다 더 많은 코드를 재사용 할 수 있습니다(<a HREF="#Inheritance">상속</a>를 보십시오).</PROS><CONS>다중 <em>implementation</em> 상속은 실제로 매우 드문 경우에만 유용합니다. 다중 구현 상속이 해결책인 것처럼 보일 때라도 흔히 더 분명하고 명확한 다른 해결책을 찾을 수 있습니다.</CONS><DECISION>다중 상속은 모든 상위 클래스가 <A HREF="#Interfaces">pure
        interfaces</A>일 때(상위 클래스 중 최초 하나는 예외일 수 있습니다)만 허용합니다. 모두가 순수 인터페이스라는 것을 확인하기 위해 <code>Interface</code> 접미어를 붙여야 합니다. <SUBSECTION title="Note:">Windows에서는 이 규칙에 <a HREF="#Windows_Code">exception</a>가 있습니다.</SUBSECTION></DECISION></BODY></STYLEPOINT><STYLEPOINT title="Interfaces"><SUMMARY>특정 상황을 만족시키는 클래스는 필요하지는 않지만 <code>Interface</code> 서픽스로 끝나는 것이 허용됩니다.</SUMMARY><BODY><DEFINITION><p>다음 조건을 만족하는 클래스는 순수 인터페이스입니다.:</p><ul><li>public인 순수 가상("<code>= 0</code>") 메소드와 정적 메소드만 있습니다 (그러나 소멸자에 대해서는 아래를 보십시오).</li><li>비정적 데이터 멤버는 없을 수 있습니다.</li><li>생성자는 정의하지 않아도 됩니다. 생성자가 있으면 인자가 없어야 하고 protected여야 합니다.</li><li>하위 클래스이면 위 조건을 만족하는 클래스만 상속해야 하고 <code>Interface</code> 접미어를 붙일 수 있습니다.</li></ul><p>
          An interface class can never be directly instantiated
          because of the pure virtual method(s) it declares.  To make
          sure all implementations of the interface can be destroyed
          correctly, the interface must also declare a virtual destructor (in
          an exception to the first rule, this should not be pure).  See
          Stroustrup, <cite>The C++ 프로그래밍 언어</cite>, 3rd
          edition, section 12.4 for details.
        </p></DEFINITION><PROS>클래스에 <code>Interface</code> 접미어를 붙이면 해당 클래스에 구현 메소드나 비정적 데이터 멤버를 추가하지 말아야 한다는 것을 알릴 수 있습니다. 이는 <A HREF="#Multiple_Inheritance">multiple inheritance</A>을 할 때 특히 중요합니다. 게다가 인터페이스 개념은 자바 프로그래머 사이에 이미 잘 알려져 있습니다.</PROS><CONS><code>Interface</code> 접미어는 클래스 이름을 길게 하므로 읽고 이해하기 어려울 수 있습니다. 게다가 인터페이스 속성은 클라이언트에 드러내지 않아야 할 상세 구현 내용으로 간주할 수 있습니다.</CONS><DECISION>위 조건에 맞을 때만 클래스 이름 끝에 <code>Interface</code>를 붙일 수 있으나 역은 아니다. 즉 위 조건을 만족하는 클래스 이름이 <code>Interface</code>로 끝나지 않아도 된다.</DECISION></BODY></STYLEPOINT><STYLEPOINT title="Operator Overloading"><SUMMARY>드물고 특별한 상황을 제외하고는 연산자를 오버로드하지 마십시오.</SUMMARY><BODY><DEFINITION>해당 클래스를 내장 타입처럼 연산하는 <code>+</code>와 <code>/</code> 같은 연산자는 중복 정의할 수 있습니다.</DEFINITION><PROS>클래스를 내장 타입(<code>int</code> 같은)과 같은 방식으로 다루므로 코드를 더 직관적으로 만들 수 있습니다. 중복 정의한 연산자는 <code>Equals()</code>이나 <code>Add()</code> 같이 딱딱해 보이는 이름의 함수에 비해 사용하기 더 좋습니다. 일부 템플릿 함수를 올바로 동작하게 하려면 연산자를 정의해야 할 수도 있습니다.</PROS><CONS>연산자 중복 정의를 통해 코드를 더 직관적으로 만들 수 있으나 몇 가지 단점이 있습니다.: <ul><li>비용이 많이 드는 연산을 어리석게도 값싼 내장 연산으로 생각하게 만들 수 있습니다.</li><li>중복 정의한 연산자를 어디서 호출하는지 더 알기 어렵습니다. 관련 있는 <code>==</code> 호출을 찾는 것보다 <code>Equals()</code>를 찾는 것이 더 쉽습니다.</li><li>일부 연산자는 포인터에도 동작하므로 버그가 생기기 쉽습니다. <code>Foo + 4</code>와 <code>&amp;Foo + 4</code>는 전혀 다른 일을 하지만, 컴파일러에서는 어느 것도 문제 없으므로 디버그 하기 매우 어렵습니다.</li></ul> 중복 정의 때문에 놀랄만한 결과가 생길 수 있습니다. 예를 들어 클래스에서 단일 연산자인 <code>operator&amp;</code>를 중복 정의하면 그 클래스를 안전하게 전방 선언할 수 없게 됩니다.</CONS><DECISION><p>일반적으로는 연산자 중복 정의를 사용하지 마십시오. 특히 대입 연산자(<code>operator=</code>)는 모르는 사이에 문제를 일으킬 수 있으므로 피해야 합니다. 이런 것이 필요하면 <code>Equals()</code>과 <code>CopyFrom()</code> 같은 함수를 정의할 수 있습니다. 마찬가지로 클래스를 전방 선언해야 할 것 같으면 위험한 단일 연산자인 <code>operator&amp;</code>는 절대로 중복 정의하지 않는다.</p><p>드물지만 템플릿이나 로그 기록을 위한 <code>operator&lt;&lt;(ostream&amp;, const T&amp;)</code>처럼 "표준" C++ 클래스와 함께 사용하기 위해 연산자를 중복 정의해야 하는 경우도 있습니다. 충분히 합당하면 그렇게 할 수 있으나 가능하면 피하는 게 좋습니다. 특히 STL 컨테이너에서 키로 사용할 수 있는 클래스에서는 <code>operator==</code>나 <code>operator&lt;</code>를 중복 정의하지 않습니다. 대신 컨테이너를 선언할 때 동등과 비교 함수자 타입을 만들어야 합니다.</p><p>일부 STL 알고리즘을 사용하려면 <code>operator==</code>를 중복 정의해야 하므로 그런 경우 이유를 문서화하고 그렇게 할 수 있습니다.</p><p><a HREF="#Copy_Constructors">복사 생성자</a>와 <a HREF="#Function_Overloading">함수 오버로딩</a>를 보십시오.</p></DECISION></BODY></STYLEPOINT><STYLEPOINT title="Access Control"><SUMMARY>데이타 멤버를 <code>private</code>으로 하십시오. 그리고 필요하다면 접근자 함수를 통해서 그들에 접근하는 방법을 제공하십시오. ( 기술적인 이유로, <A HREF="http://code.google.com/p/googletest/">Google Test</A>를 사용할 때, test fixture 클래스의 데이타 멤버는 <code>protected</code> 입니다.) 일반적으로 변수는 <code>foo_</code>로 불려질 것입니다. 그리고 접근자 함수는 <code>foo()</code>로 불려질 것입니다. 또한 수정자 함수 <code>set_foo()</code>가 필요할 지도 모릅니다. 예외: <code>static const</code> 데이타 멤버(일반적으로 <code>kFoo</code>로 불리는)는 <code>private</code>일 필요가 없습니다.</SUMMARY><BODY><p>접근자의 정의는 흔히 헤더 파일에 인라인으로 정의합니다.</p><p><a HREF="#Inheritance">상속</a>와 <a HREF="#Function_Names">함수 이름들</a>를 보십시오.</p></BODY></STYLEPOINT><STYLEPOINT title="Declaration Order"><SUMMARY>클래스내에서 선언에서 지정된 순서를 사용하십시오: <code>private:</code> 전에 <code>public:</code>, 데이타 멤버(변수들)전에 메소드들, 등등.</SUMMARY><BODY><p>클래스 정의는 <code>public:</code> 섹션으로 시작해야 합니다. 다음으로 <code>protected:</code> 섹션이 오고, 그리고 <code>private:</code> 섹션이 옵니다. 만약 이 섹션중의 하나가 비어있다면, 생략하십시오.</p><p>각 섹션속에서, 일반적으로 선언은 다음의 순서로 있어야만 합니다.:</p><ul><li>Typedefs와 Enums</li><li>상수 (<code>static const</code> 데이타 멤버)</li><li>생성자</li><li>소멸자</li><li>정적 메소드를 포함한 메소드들</li><li>데이타 멤버 (<code>static const</code> 데이타 멤버를 제외하고)</li></ul><p>프렌드 선언은 항상 private 구역에 두며 <code>DISALLOW_COPY_AND_ASSIGN</code> 매크로는 <code>private:</code> 구역 마지막에서 호출합니다. 즉 클래스에서 가장 마지막 내용이어야 합니다. 복사 생성자(Copy Constructors)를 참조합니다. <a HREF="#Copy_Constructors">복사 생성자</a>를 보십시오.</p><p><code>.cc</code> 파일에서 메소드를 정의할 때는 최대한 선언한 순서와 같도록 해야 합니다.</p><p>클래스 정의에 큰 메소드 정의 inline을 넣지 마십시오. 보통 사소하거나, 성능이 중요하거나, 매우 작은 메소드들이 inline으로 정의될 지도 모릅니다. 더 상세한 내용은 <a HREF="#Inline_Functions">Inline 함수들</a>를 보십시오.</p></BODY></STYLEPOINT><STYLEPOINT title="Write Short Functions"><SUMMARY>작고 집중된 함수를 선호하십시오.</SUMMARY><BODY><p>긴 함수가 때로는 적절하다는 것을 알고 있습니다. 따랏 함수 길이에 대한 강력한 제한은 없습니다. 만약 함수가 40 라인을 넘어선다면, 프로그램의 구조를 해치지 않는 범위내에서 나누어질 수 있는지 없는지 생각해 보십시오.</p><p>긴 함수가 지금 완벽하게 동작하고, 몇달 후에 어떤 사람이 수정해서 새로운 기능을 추가한 다면. 이것은 찾기 어려운 버그를 만들 수 있습니다. 함수를 짧고 간단하게 유지하는 것은 다른 사람이 코드를 더 쉽게 읽고 수정하도록 만들어 줍니다.</p><p>어떤 코드로 작업하고 있을 때 길고 복잡한 함수를 만날 수도 있습니다. 기존 코드를 변경하는데 겁먹을 필요는 없습니다. 그런 함수를 다루거나 오류를 디버그 하는 게 어렵거나 그런 함수의 일부분을 다른 몇 곳에서 사용하고 싶으면 해당 함수를 더 작고 더 다루기 쉬운 조각으로 나누는 것을 고려하십시오.</p></BODY></STYLEPOINT></CATEGORY>

<CATEGORY title="Google-Specific Magic">
  
  <p>우리가 C++ 코드를 더 견고하게 만들기 위해서 사용하는 다양한 트릭과 유틸리티들이 있습니다. 그리고 우리가 C++을 사용하는 다양한 방법들은 다른 곳에서 본 것고는 다를지도 모릅니다.</p>

  

  <STYLEPOINT title="Smart Pointers">
    
    <SUMMARY>실제로 포인터가 필요하다면, <code>scoped_ptr</code>가 좋습니다. 오브젝트의 소유권을 공유하는 것이 정말로 필요한 경우에만 non-const referent와 함께 <code>std::tr1::shared_ptr</code>를 사용해야만 합니다 (예를 들면, STL 컨테이너 내부). <code>auto_ptr</code>은 절대로 사용해서는 않됩니다.</SUMMARY>
    <BODY>
      <DEFINITION>"Smart" 포인터는 포인터처럼 동작하는 객체지만, 뒤쪽의 메모리 관리를 자동화합니다.</DEFINITION>
      <PROS>Smart 포인터는 메모리 릭을 방지하는데 극단적으로 유용합니다. 예외에 안전한 코드를 작성하는데 반드시 필요합니다. 또한 동적으로 할당된 메모리를 정규화하고 문서화합니다.</PROS>
      <CONS>객체를 설계할 때는 소유자가 하나이며, 소유자 역시 고정하는 것을 우선으로 합니다. 스마트 포인터는 소유권을 공유하거나 옮길 수 있어, 마치 소유권을 의미적으로 유효하도록 조심스럽게 설계할 수 있는 유혹적인 대체 방안인 것처럼 보일 수 있습니다. 하지만 코드를 혼란스럽게 하고 심지어 메모리를 절대 삭제할 수 없는 버그가 생길 수 있습니다. 스마트 포인터(특히 <code>auto_ptr</code>)의 실제 의미가 불명확하고 혼란스러울 수 있습니다. 스마트 포인터를 사용할 때 얻는 예외 안전성은 그리 중요하지 않습니다. 예외를 허용하지 않기 때문입니다.</CONS>
      <DECISION>
        <dl>
          <dt><code>scoped_ptr</code></dt>
          <dd>직관적이며 안전합니다. 사용할 수 있는 곳은 어디서나 사용하십시오.</dd>
          <dt><code>auto_ptr</code></dt>
          <dd>혼란스럽고 버그를 발생하기 쉬운 소유권 이전 방법입니다. 사용하지 마십시오.</dd>
          <dt><code>shared_ptr</code></dt>
          <dd>const 레퍼런스에 대해서 안전합니다 (예를 들면. <code>shared_ptr&lt;const T&gt;</code>). const가 아닌 레퍼런트에서 레퍼런스-카운트된 포인터를 가끔 최고의 설계가 될 수 있습니다. 하지만 가능한한 하나의 소유자를 가지도록 새롭게 작성하도록 노력하십시오.</dd>
        </dl>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="cpplint">
    <SUMMARY>스타일 에러를 검출하기 위해서 <code>cpplint.py</code>를 사용하십시오.</SUMMARY>
    <BODY>
      <p><code>cpplint.py</code>는 소스 파일을 읽어 많은 스타일 오류를 확인하는 도구입니다. 완벽하지 않으며 거짓 양성과 거짓 음성 결과를 모두 줄 수 있지만 여전히 가치가 있습니다. 거짓 양성 결과는 줄 끝에 <code>// NOLINT</code>를 추가해 무시할 수 있습니다.</p>
      
      <p>프로젝트 자체 툴에서 <code>cpplint.py</code>를 실행하는 방법을 설명한 프로젝트도 일부 있습니다. 참여하고 있는 프로젝트가 그렇지 않으면 <A HREF="http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py"><code>cpplint.py</code></A>를 따로 받을 수도 있다.</p>
    </BODY>
  </STYLEPOINT>

  
</CATEGORY>

<CATEGORY title="Other C++ Features">
  <STYLEPOINT title="Reference Arguments">
    <SUMMARY>레퍼런스로 전달되는 모든 파라메터들은 <code>const</code>여야만 합니다.</SUMMARY>
    <BODY>
      <DEFINITION>C에서는 함수에서 변수 내용을 바꿔야 하면 <code>int foo(int *pval)</code>처럼 매개변수를 포인터로 해야 합니다. C++에서는 다른 방법으로 <code>int foo(int &amp;val)</code>처럼 매개변수를 참조자로 선언할 수 있습니다.</DEFINITION>
      <PROS>
        Defining a parameter as reference avoids ugly code like
        <code>(*pval)++</code>.  Necessary for some applications like
        copy constructors.  Makes it clear, unlike with pointers, that
        a null pointer is not a possible value.
      </PROS>
      <CONS>참조자는 문법적으로는 값처럼 보이지만 의미적으로는 포인터이므로 혼란스러울 수 있습니다.</CONS>
      <DECISION>
        <p>함수 매개변수에서 모든 참조자는 <code>const</code>여야 한다.</p>
        <CODE_SNIPPET>
          void Foo(const string &amp;in, string *out);
        </CODE_SNIPPET>
        <p>사실 구글 코드에서는 입력 인자를 값 또는 <code>const</code> 참조자로, 출력 인자를 포인터로 사용하는 것이 관례로 매우 강하게 굳어져 있습니다. 입력 매개변수로 <code>const</code> 포인터를 쓸 수는 있지만 <code>const</code>가 아닌 참조자 매개변수는 절대로 안 됩니다.</p>
        <p>

         However, there are some instances where using <code>const T*</code>
         is preferable to <code>const T&amp;</code> for input parameters. For
         example:
         <ul>
           <li>You want to pass in a null pointer.</li>
           <li>The function saves a pointer or reference to the input.</li>
         </ul>
         

         Remember that most of the time input parameters are going to be
         specified as <code>const T&amp;</code>.  Using <code>const T*</code>
         instead communicates to the reader that the input is somehow treated
         differently.  So if you choose <code>const T*</code> rather than
         <code>const T&amp;</code>, do so for a concrete reason; otherwise it
         will likely confuse readers by making them look for an explanation
         that doesn't exist.

        </p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Overloading">
    <SUMMARY>함수를 호출하는 쪽에서 오버로드된 함수중 어떤 것이 호출될지 정확히 몰라도 무슨일이 일어나는 지를 알 수 있을 때만 오버로드된 함수(생성자를 포함해서)를 사용하십시오.</SUMMARY>
    <BODY>
      <DEFINITION>
        <p><code>const string&amp;</code>를 취하는 함수를 만든 다음 <code>const char*</code>를 취하는 다른 함수를 중복 정의할 수 있습니다.</p>
        <CODE_SNIPPET>
          class MyClass {
           public:
            void Analyze(const string &amp;text);
            void Analyze(const char *text, size_t textlen);
          };
        </CODE_SNIPPET>
      </DEFINITION>
      <PROS>중복 정의를 사용하면 이름은 같으나 취하는 인자가 다른 함수를 만들 수 있어 코드를 더 직관적으로 만들 수 있습니다. 중복 정의는 템플릿 코드에서 사용할 수 있고 비지터(visitor) 패턴에서 편리합니다.</PROS>
      <CONS>인자 타입만으로 함수를 중복 정의했을 때 어떤 일이 생기는지 알려면 복잡한 C++ 일치 규칙을 알아야 할 수 있습니다. 게다가 어떤 함수의 여러 변형 중 일부만을 파생 클래스에서 재정의(override)해 상속하면 많은 이들이 혼란스러워 합니다.</CONS>
      <DECISION>함수를 중복 정의하고 싶으면 <code>Append()</code>로만 쓰는 대신 <code>Append()</code>, <code>Append()</code>처럼 인자에 대한 정보를 이름에 붙이는 것을 고려해 봅니다.</DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Default Arguments">
    <SUMMARY>
      We do not allow default function parameters, except in limited
      situations as explained below.  Simulate them with function
      overloading instead, if appropriate.
    </SUMMARY>
    <BODY>
      <PROS>
        Often you have a function that uses default values, but
        occasionally you want to override the defaults.  Default
        parameters allow an easy way to do this without having to
        define many functions for the rare exceptions.  Compared to
        overloading the function, default arguments have a cleaner
        syntax, with less boilerplate and a clearer distinction
        between 'required' and 'optional' arguments.
      </PROS>
      <CONS>
        Function pointers are confusing in the presence of default
        arguments, since the function signature often doesn't match
        the call signature.  Adding a default argument to an existing
        function changes its type, which can cause problems with code
        taking its address.  Adding function overloads avoids these
        problems.  In addition, default parameters may result in
        bulkier code since they are replicated at every call-site --
        as opposed to overloaded functions, where "the default"
        appears only in the function definition.
      </CONS>
      <DECISION>
        <p>
          While the cons above are not that onerous, they still
          outweigh the (small) benefits of default arguments over
          function overloading.  So except as described below, we
          require all arguments to be explicitly specified.
        </p>
        <p>
          One specific exception is when the function is a static
          function (or in an unnamed namespace) in a .cc file.  In
          this case, the cons don't apply since the function's use is
          so localized.
        </p>
        <p>
          Another specific exception is when default arguments are
          used to simulate variable-length argument lists.
        </p>
        <CODE_SNIPPET>
          // Support up to 4 params by using a default empty AlphaNum.
          string StrCat(const AlphaNum &amp;a,
                        const AlphaNum &amp;b = gEmptyAlphaNum,
                        const AlphaNum &amp;c = gEmptyAlphaNum,
                        const AlphaNum &amp;d = gEmptyAlphaNum);
        </CODE_SNIPPET>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Variable-Length Arrays and alloca()">
    <SUMMARY>variable-length arrays 혹은 <code>alloca()</code>를 허용하지 않습니다.</SUMMARY>
    <BODY>
      <PROS>Variable-length arrays는 문법이 자연스러워 보입니다. variable-length arrays와 <code>alloca()</code>는 모두 매우 효율적입니다.</PROS>
      <CONS>Variable-length arrays과 alloca()는 표준 C++ 부분이 아닙니다. 더 중요한 것은, 데이터 크기에 의존해 스택에 공간을 할당하며 메모리를 덮어쓰는 찾기 어려운 버그를 일으킬 수 있다는 점입니다. 즉 다음과 같은 상황입니다. "내 컴퓨터에서는 잘 동작하는데 실제 제품에서는 이상하게 종료됩니다."</CONS>
      
      <DECISION>대신 <code>scoped_ptr</code>/<code>scoped_array</code>처럼 안전한 할당자를 사용하십시오.</DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Friends">
    <SUMMARY>이유가 있을 때만 <code>friend</code> 클래스와 함수의 사용을 허용할 것입니다.</SUMMARY>
    <BODY>
      <p>일반적으로 프렌드는 같은 파일에서 정의하므로 다른 파일을 살펴보지 않아도 클래스에서 private 멤버를 사용하는 것을 알 수 있습니다. <code>friend</code>를 사용하는 일반적인 방법은 <code>FooBuilder</code> 클래스를 <code>Foo</code>의 프렌드로 만들어 <code>Foo</code>의 내부 상태를 밖으로 드러내지 않고도 그 상태를 올바르게 만들 수 있게 하는 것입니다. 때로는 단위 테스트 클래스를 테스트할 클래스의 프렌드로 만드는 것이 유용할 수도 있습니다.</p>
      <p>프렌드는 클래스의 캡슐화 범위를 넓히지만 망가뜨리지는 않습니다. 어떤 경우에는 멤버를 public으로 하는 것보다 다른 클래스 하나에서만 접근할 수 있게 하는 게 더 좋습니다. 하지만 대부분의 클래스에서는 public 멤버를 통해서 다른 클래스와 상호작용 하도록 하는 게 좋습니다.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Exceptions">
    <SUMMARY>C++ 예외를 사용하지 않을 것입니다.</SUMMARY>
    <BODY>
      <PROS>
        <ul>
          <li>예외를 사용하면 오류 코드를 사용할 때 생길 수 있는 불명확함이나 오류를 만들기 쉬운 문제 없이, 깊게 중첩된 함수에서 "생기지 않아야 할" 실패를 어떻게 처리할지 응용 프로그램의 더 상위 수준에서 결정할 수 있다.</li>

          

          <li>예외는 현대 언어 대부분에서 사용됩니다. C++에서 사용함으로써 파이썬, 자바와 더 일관성 있게 되고 다른 언어에서도 C++에 더 친숙하게 됩니다.</li>

          <li>일부 서드 파티 C++ 라이브러리에서는 예외를 사용하므로 내부적으로 그 기능을 끄고 통합하기 더 어렵습니다.</li>

          <li>예외는 생성자에서 실패를 알리는 유일한 방법입니다. 이를 팩토리 함수나 <code>Init()</code> 메소드로 시뮬레이션 할 수 있지만 이 역시 각각 힙을 할당하거나 새로운 "무효(invalid)" 상태를 만들어야 합니다.</li>

          <li>예외는 테스트 프레임워크에서 정말 간편합니다.</li>
        </ul>
      </PROS>
      <CONS>
        <ul>
          <li>기존 함수에 <code>throw</code> 문을 추가하면 중간에 호출하는 곳을 모두 살펴봐야 합니다. 호출하는 곳에서 적어도 기본 예외 안전성을 반드시 보장하도록 하든지 예외를 잡지 않아 결과적으로 프로그램을 종료하도록 해야 합니다. 예를 들어 <code>f()</code>에서 <code>g()</code>를 호출하고 <code>h()</code>를 호출할 때, <code>f</code>에서 잡을 수 있는 예외를 <code>h</code>에서 발생하면 <code>g</code>에서는 조심스럽게 처리하든지 적절히 처리하지 못할 수 있습니다.</li>

          <li>더 일반적으로 예외를 사용하면 코드를 살펴볼 때 프로그램 제어 흐름을 알기 어렵게 합니다. 생각하지 않은 곳에서 함수를 반환할 수 있기 때문입니다. 이 때문에 유지보수성과 디버깅이 어려워집니다. 예외를 어디서 어떻게 써야 하는지 규칙을 정해 이런 비용을 최소화할 수 있지만 개발자가 그 규칙을 알고 이해하는데 더 많은 비용이 듭니다.</li>

          <li>예외 안전성은 RAII와 다른 코딩 사례 모두에서 필요합니다. 예외를 지원하는 많은 컴퓨터에서 예외 안전한 코드를 올바르고 쉽게 만들 수 있도록 해야 합니다. 더욱이 개발자가 전체 호출 경로를 이해하지 않아도 되도록 예외 안전한 코드에서는 로직을 영속적인 상태로 작성하고, "발생(commit)" 단계로 고립시켜야 합니다. 이렇게 함으로써 이점과 (어쩌면 발생 단계로 고립시켜 코드를 난해하게 만드는) 비용이 모두 생깁니다. 예외를 사용하면 그 것이 가치가 없을지라도 항상 그런 비용을 지불하도록 강제합니다.</li>

          <li>예외를 켜면 생성한 각 바이너리에 데이터를 추가해 컴파일 시간이 (아마도 약간) 늘어날 것이고 주소 공간에 대한 압박이 증가할 수 있습니다.</li>

          <li>예외를 사용할 수 있으면 예외를 발생하는 것이 적합하지 않거나 예외에서 회복하는 것이 안전하지 않을 때에도 개발자가 그렇게 하도록 할 수 있습니다. 예를 들어 사용자가 잘못 입력했을 때는 예외를 발생하지 않아야 합니다. 이러한 제한에 대해 더 길더라도 스타일 안내서를 문서화해야 합니다!</li>
        </ul>
      </CONS>
      <DECISION>
        <p>각자 상황에서는 예외를 사용해 얻는 이점이 비용보다 더 크며 특히 새 프로젝트에서 더 그렇습니다. 하지만 기존 코드에 예외를 도입하면 의존하는 모든 코드에 영향을 미칩니다. 새 프로젝트에만 한정해 예외를 쓰는 게 아니라면 예외를 사용하지 않는 기존 코드에 새 프로젝트를 통합하는 것 역시 문제가 됩니다. 구글에서 만든 대부분의 C++ 코드는 예외를 처리할 수 있도록 되어 있지 않으므로 예외를 발생하는 새 코드를 도입하는 것이 상대적으로 어렵습니다.</p>
        <p>구글에서 만든 기존 코드는 예외와 잘 어울리지 않으므로 예외를 사용하는 비용이 새 프로젝트에서 드는 것보다 다소 더 클 수 있습니다. 또한 변환 과정 역시 느리고 오류도 발생하기 쉽습니다. 예외는 큰 부담이 생기지만 오류 코드와 단정문 정도로 예외를 대체할 수 있는 방법이 있다고는 생각하지 않습니다.</p>
        <p>예외 사용에 대해 할 수 있는 조언은 철학이나 도덕에 근거한 것이 아니라 실용주의적입니다. 구글에서는 자체적으로 만든 오픈 소스 프로젝트를 사용하길 좋아하는데 그런 프로젝트에서 예외를 사용하면 그렇게 하기 어려우므로 구글 오픈 소스 프로젝트에서도 예외에 대한 조언이 필요합니다. 처음부터 다시 모든 것에 대해 그렇게 해 왔다면 아마 좀 달랐을 것입니다.</p>
        <p>윈도 코드에서는 이 규칙에 <a HREF="#Windows_Code">exception</a>가 있습니다.</p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Run-Time Type Information (RTTI)">
    <SUMMARY>
      Avoid using Run Time Type Information (RTTI).
    </SUMMARY>
    <BODY>
      <DEFINITION>
        RTTI allows a programmer to query the C++ class of an
        object at run time.  This is done by use of <code>typeid</code> or
        <code>dynamic_cast</code>.
      </DEFINITION>
      <CONS>
        <p>
         Querying the type of an object at run-time frequently means a
         design problem.  Needing to know the type of an
         object at runtime is often an indication that
         the design of your class hierarchy is flawed.
        </p>
        <p>
         Undisciplined use of RTTI makes code hard to maintain.  It can
         lead to type-based decision trees or switch statements scattered
         throughout the code, all of which must be examined when making
         further changes.
        </p>
      </CONS>
      <PROS>
        <p>
          The standard alternatives to RTTI (described below) require
          modification or redesign of the class hierarchy in question.
          Sometimes such modifications are infeasible or undesirable,
          particularly in widely-used or mature code.
        </p>
        <p>
          RTTI can be useful in some unit tests. For example, it is useful in
          tests of factory classes where the test has to verify that a
          newly created object has the expected dynamic type.  It is also
          useful in managing the relationship between objects and their mocks.
        </p>
        <p>
          RTTI is useful when considering multiple abstract objects.  Consider
          <CODE_SNIPPET>
            bool Base::Equal(Base* other) = 0;
            bool Derived::Equal(Base* other) {
              Derived* that = dynamic_cast&lt;Derived*&gt;(other);
              if (that == NULL)
                return false;
              ...
            }
          </CODE_SNIPPET>
        </p>

      </PROS>
      <DECISION>
        <p>
          RTTI has legitimate uses but is prone to abuse, so you must
          be careful when using it.  You may use it freely
          in unittests, but avoid it when possible in other code.
          In particular, think twice before using RTTI in new code.
          If you find yourself needing to write code that behaves differently
          based on the class of an object, consider one of the following
          alternatives to querying the type:
        <ul>
          <li>가상 메소드는 특정 하위 클래스 타입에 따라 다른 코드를 실행할 수 있는 더 좋은 방법입니다. 이는 그런 동작을 객체 내에 넣습니다.</li>
          <li>만약 그런 동작이 객체에 속하지 않으나 대신 어떤 처리 코드(processing code)에 속한다면 비지터 디자인 패턴과 같은 이중 호출(double-dispatch) 해법을 고려합니다. 이를 사용하면 내장 타입 시스템을 사용하는 클래스 타입을 결정하는데 객체에 속하지 않는 방법을 사용할 수 있습니다.</li>
        </ul>
        </p>
        <p>
          When the logic of a program guarantees that a given instance
          of a base class is in fact an instance of a particular derived class,
          then a <code>dynamic_cast</code> may be used freely on the object.
          
          Usually one can use a
          <code>static_cast</code> as an alternative in such situations.
        </p>
        <p>
          Decision trees based on type are a strong indication that your
          code is on the wrong track.
          <BAD_CODE_SNIPPET>
            if (typeid(*data) == typeid(D1)) {
              ...
            } else if (typeid(*data) == typeid(D2)) {
              ...
            } else if (typeid(*data) == typeid(D3)) {
            ...
          </BAD_CODE_SNIPPET>
          Code such as this usually breaks when additional subclasses are
          added to the class hierarchy.  Moreover, when properties of a subclass
          change, it is difficult to find and modify all the affected code segments.
        </p>
        <p>
          Do not hand-implement an RTTI-like workaround. The arguments
          against RTTI apply just as much to workarounds like class
          hierarchies with type tags.  Moreover, workarounds disguise your
          true intent.
        </p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Casting">
    <SUMMARY><code>static_cast&lt;&gt;()</code> 같은 C++ 캐스트를 사용하라. <code>int y = (int)x;</code>와 <code>int y = int(x);</code> 같은 다른 캐스트 포멧을 사용하지마십시오.</SUMMARY>
    <BODY>
      <DEFINITION>C++은 캐스트 동작의 타입을 구분하기 위해서 C와는 다른 캐스트 시스템을 소개했습니다.</DEFINITION>
      <PROS>C 캐스트의 문제점은 동작이 모호하다는 것입니다; 때로는 <em>변환</em>을 수행하고 (예를 들면, <code>(int)3.5</code>) 때로는 <em>캐스트</em>를 수행합니다 (예를 들면, <code>(int)"hello"</code>); C++ 캐스트는 이러한 모호성을 피합니다. 덧붙여서 C++ 캐스트는 캐스트을 찾을 때 더 쉽게 찾을 수 있습니다.</PROS>
      <CONS>구문이 다루기 어렵습니다.</CONS>
      <DECISION>
        <p>C 스타일의 캐스트를 사용하지 마십시오. 대신 다음과 같은 C++ 스타일의 캐스트를 사용하십시오.</p>
        <ul>
          
          <li>값의 변환을 수행하는 C 스타일의 캐스트와 동일한 캐스트가 필요하거나 혹은 클래스에서 그것의 파생 클래스로의 명시적인 up-cast 포인터가 필요한 경우에 <code>static_cast</code>를 사용하십시오.</li>
          <li><code>const</code> 한정자를 제거하기 위해서 <code>const_cast</code>를 사용하십시오(<a HREF="#Use_of_const">const</a>를 보십시오).</li>
          
          
          <li>정수와 포인터 타입 그리고 다른 포인터 타입 사이의 안전하지 않은 변환을 수행하기 위해서 <code>reinterpret_cast</code>를 사용하십시오. 무엇을 하고 있는지 알고 있고 aliasing 문제를 이해하고 있는 경우에만 이것을 사용하십시오.</li>
        </ul>
        <p> See the <a href="#Run-Time_Type_Information__RTTI_">RTTI section</a>
            for guidance on the use of <code>dynamic_cast</code>.
            </p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Streams">
    <SUMMARY>단지 로깅을 위해서만 streams을 사용하십시오.</SUMMARY>
    <BODY>
      <DEFINITION>Streams은 <code>printf()</code>와 <code>scanf()</code>에 대한 대체품입니다..</DEFINITION>
      <PROS>stream에 대해서, 출력하고 있는 오브젝트의 타입을 알 필요가 없습니다. 포멧 스트링과 아규먼트 리스트가 일치하는 지에 대한 문제도 없습니다. (gcc에서는 <code>printf</code>의 문제가 없습니다.) stream은 상응하는 파일을 열고 닫는 자동 생성자와 소멸자를 가집니다.</PROS>
      <CONS>스트림은 <code>pread()</code>처럼 다루기 어렵습니다. <code>printf</code>를 사용하지 않고 스트림을 사용해 효율적으로 처리하는 게 불가능하지 않을지라도, 특히 일반적인 형식 문자열 관용구인 <code>%.*s</code>처럼 어떤 형식 문자열은 어렵습니다. 국제화에 많이 도움되는 <code>%1s</code> 지시자 같은 재정렬 연산자를 스트림에서는 지원하지 않습니다.</CONS>
      <DECISION>
        
        <p>로깅 인터페이스에 의해서 필요로 하는 곳을 제외하고는 stream을 사용하지 마십시오. 대신에 <code>printf</code> 같은 루틴을 사용하십시오.</p>
        <p>스트림을 사용하는 데에는 다양한 장단점이 있으나 이 역시 다른 많은 경우에서처럼 일관성이 가장 중요합니다. 코드에 스트림을 사용하지 마십시오.</p>

        <SUBSECTION title="Extended Discussion">
          <p>여기에는 논쟁이 있으므로 그 논거를 더 깊게 설명합니다. 단 한 가지 방법을 사용한다는 지침을 떠 올려 봅시다. 즉 어떤 타입의 I/O를 처리하는 모든 곳에서 코드가 같게 보이도록 하고 싶습니다. 그러므로 스트림을 사용할지 <code>printf</code>에 읽기/쓰기를 함께 사용할지 사용자가 선택하도록 하고 싶진 않으며, 대신 둘 중 하나를 선택해야 합니다. 이는 매우 특수한 경우이며 역사적인 이유로 로그를 기록하는 것은 예외로 했습니다.</p>
          <p>스트림을 옹호하는 쪽에서는 둘 중 스트림을 선택하는 게 명확하다고 주장하지만 이 문제는 사실 그렇게 명확하지 않습니다. 스트림을 사용할 때 얻는 장점 각각에 대해 단점 역시 모두 있습니다. 가장 큰 장점은 출력할 객체 타입을 몰라도 된다는 것입니다. 이는 대단한 것입니다. 하지만 역으로 잘못된 타입을 사용하기 쉽고 컴파일러에서는 그에 대해 경고하지 않습니다. 즉 스트림을 사용할 때는 이런 실수를 모르고 하기 쉽습니다.</p>
          <CODE_SNIPPET>
            cout &lt;&lt; this;  // Prints the address
            cout &lt;&lt; *this;  // Prints the contents
          </CODE_SNIPPET>
          <p><code>&lt;&lt;</code>를 중복 정의했기 때문에 컴파일러에서는 오류를 발생하지 않는다. 이 때문에 중복 정의를 권하지 않는다.</p>
          <p>일부는 <code>printf</code> 형식 문자열이 보기 안 좋고 읽기도 어렵다고 합니다. 하지만 스트림은 때때로 더 안 좋습니다. 다음 두 코드 조각을 살펴봅시다. 둘 모두 같은 의미입니다. 어느 것이 이해하기 더 쉬울까요? </p>
          <CODE_SNIPPET>
             cerr &lt;&lt; "Error connecting to '" &lt;&lt; foo-&gt;bar()-&gt;hostname.first
                  &lt;&lt; ":" &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; ": " &lt;&lt; strerror(errno);

             fprintf(stderr, "Error connecting to '%s:%u: %s",
                     foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second,
                     strerror(errno));
          </CODE_SNIPPET>
          <p>기타 등등의 다른 문제를 거론할 수도 있습니다 ("올바른 래퍼를 사용하는 게 더 좋습니다."라고 주장할 수도 있습니다. 하지만 그게 한 경우에 맞다고 해서 다른 경우에도 그럴까요? 게다가 누구간 배워야 할 것을 더 추가하는 게 아니라 이 언어를 더 작게 만드는 게 목적이라는 걸 기억해야 합니다).</p>
          <p>어느 것이든 서로 다른 장단점이 있으며 명확히 더 우월한 해결책은 없습니다. 단순주의에 따라 그 중 하나를 선택해야 하며 결정은 <code>printf</code> + <code>read</code>/<code>write</code> 였습니다.</p>
        </SUBSECTION>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Preincrement and Predecrement">
    <SUMMARY>반복자와 다른 템플릿 오브젝트에 대해서 증가, 감소 연산자에서 전위 형태(<code>++i</code>)를 사용하십시오.</SUMMARY>
    <BODY>
      <DEFINITION>변수를 증가(<code>++i</code> 또는 <code>i++</code>) 또는 감소(<code>--i</code> 또는 <code>i--</code>)할 때 그 값을 표현식에서 사용하지 않으면 전위 증가(감소) 또는 후위 증가(감소) 중 하나를 선택하면 됩니다.</DEFINITION>
      <PROS>반환 값을 사용하지 않을 때 "전위"형(<code>++i</code>)은 "후위"형(<code>i++</code>)보다 효율이 떨어지지 않으며 종종 더 효율적입니다. 이는 후위 증가(또는 감소)를 할 때는 표현식에서 사용하기 위해 <code>i</code>에 대한 복사본을 만들어야 하기 때문입니다. <code>i</code>가 반복자나 스칼라(scalar)가 아닌 타입이면 <code>i</code>를 복사하는 데에 비용이 많이 듭니다. 두 가지 증가 형식은 그 값을 사용하지 않을 때 똑같이 동작하는데 항상 전위 증가를 사용하지 않을 이유가 있을까요?</PROS>
      <CONS>전통적으로 C로 개발해 오면서 표현식 값을 사용하지 않을 때는 후위 증가를 사용했으며 특히 <code>for</code> 루프에서 그렇습니다. 일부는 후위 증가를 사용하는 게 더 읽기 쉽다는 것을 압니다. 영어처럼 "주어"(<code>i</code>)가 "동사"(<code>++</code>)보다 앞에 나오기 때문입니다.</CONS>
      <DECISION>객체가 아닌 단순 스칼라 값일 때는 어느 것을 쓰든 괜찮습니다. 반복자와 템플릿 타입에 대해서는 전위 증가를 사용합니다</DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Use of const">
    <SUMMARY>
      Use <code>const</code> whenever it makes sense.
    </SUMMARY>
    <BODY>
      <DEFINITION>변수와 매개변수를 선언할 때 <code>const int foo</code>처럼 <code>const</code>를 앞에 둬 그 변수가 바뀌지 않는다는 것을 나타낼 수 있습니다. <code>class Foo { int Bar(char c) const; };</code>처럼 클래스 함수에 <code>const</code> 한정자를 사용해 그 함수에서 해당 클래스 멤버 변수 상태를 바꾸지 않는다는 것을 나타낼 수 있습니다.</DEFINITION>
      <PROS>변수를 어떻게 사용하는지 더 쉽게 이해할 수 있습니다. 컴파일러에서 타입 검사를 더 잘 할 수 있으며 더 나은 코드를 만들게 합니다. 호출하는 함수에서 변수를 바꾸는데 제한이 있는지 알 수 있으므로 프로그램이 올바른지 파악하는데 도움이 됩니다. 다중 스레드 프로그램에서 어떤 함수를 잠김 현상 없이 사용할 수 있는지 아는데 도움이 됩니다.</PROS>
      <CONS><code>const</code>는 바이러스같습니다. <code>const</code> 변수를 함수에 전달하면 그 함수 역시 원형 선언(prototype)에 <code>const</code>를 사용해야 합니다(또는 그 변수에 <code>const_cast</code>를 해야 합니다). 이는 라이브러리 함수를 호출할 때 특별한 문제가 될 수 있습니다.</CONS>
      <DECISION>
        <p><code>const</code> 변수, 데이터 멤버, 메소드, 인자는 컴파일 시점에 타입 검사를 합니다. 가능한 빨리 오류를 찾는 게 더 낫기 때문입니다. 그러므로 타당하다면 언제나 <code>const</code>를 사용하기를 강하게 권합니다.</p>
        <ul>
          <li>함수에서 참조나 포인터로 전달한 인자를 변경하지 않으면 그 인자는 <code>const</code>여야 합니다.</li>
          <li>가능하면 언제나 메소드는 <code>const</code>로 선언합니다. 접근자는 거의 언제나 <code>const</code>여야 합니다. 다른 메소드인 경우, 데이터 멤버를 전혀 변경하지 않고 <code>const</code> 메소드가 아닌 것은 호출하지 않으며 <code>const</code>가 아닌 포인터나 <code>const</code>가 아닌 참조자를 데이터 멤버에 반환하지 않으면 const여야 합니다.</li>
          <li>생성 후 변경하지 않아도 되는 데이터 멤버는 <code>const</code>로 만들 것을 고려합니다.</li>
        </ul>
        <p><code>mutable</code> 키워드도 쓸 수 있으나 스레드에서는 안전하지 않으므로 스레드 안전성을 먼저 조심스레 생각해야 합니다.</p>
      </DECISION>
      <SUBSECTION title="Where to put the const">
        <p>
          Some people favor the form <code>int const *foo</code> to
          <code>const int* foo</code>.  They argue that this is more
          readable because it's more consistent: it keeps the rule
          that <code>const</code> always follows the object it's
          describing.  However, this consistency argument doesn't
          apply in codebases with few deeply-nested pointer
          expressions since most <code>const</code> expressions have
          only one <code>const</code>, and it applies to the
          underlying value.  In such cases, there's no consistency to
          maintain.
          Putting the <code>const</code> first is arguably more readable,
          since it follows English in putting the "adjective"
          (<code>const</code>) before the "noun" (<code>int</code>).
        </p>
        <p><code>const</code>를 먼저 넣는 것을 권장하지만, 요구하지는 않습니다. 주변의 코드와 일관성을 유지하십시오!</p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Integer Types">
    <SUMMARY>내장된 C++ 정수 타입중에, 사용되는 유일한 것은 <code>int</code>입니다. 만약 프로그램에서 다양한 크기의 변수가 필요하다면, <code>&lt;stdint.h&gt;</code>에서 <code>int16_t</code>같은 정확한-폭의 정수 타입을 사용하십시오</SUMMARY>
    <BODY>
      <DEFINITION>C++에서는 정수형에 크기를 지정하지 않으며 일반적으로 <code>short</code>는 16비트, <code>int</code>는 32비트, <code>long</code>은 32비트, <code>long long</code>은 64비트로 간주한다.</DEFINITION>
      <PROS>선언이 일정하다.</PROS>
      <CONS>C++에서 정수형 크기가 컴파일러와 구조에 따라 바뀔 수 있다.</CONS>
      <DECISION>
        <p><code>&lt;stdint.h&gt;</code>에서는 <code>int16_t</code>, <code>uint32_t</code>, <code>int64_t</code>등을 정의한다. 정수 크기를 보장해야 할 때는 <code>short</code>, <code>unsigned long long</code> 대신 항상 사용한다. C 정수형에서는 <code>int</code>만 사용한다. 적절한 경우에는 <code>size_t</code>와 <code>ptrdiff_t</code>와 같은 표준 타입을 사용해도 좋다.</p>
        <p><code>int</code>는 루프 카운터처럼 너무 커지지 않는 정수에 대해 매우 자주 사용한다. 이런 일반적인 상황에는 평범하고 오래된 <code>int</code>를 사용한다. <code>int</code>는 적어도 32비트라고 가정할 수는 있으나 32비트보다 크다고 가정해서는 안 된다. 64비트 정수형이 필요하면 <code>int64_t</code> 또는 <code>uint64_t</code>를 사용한다.</p>
        <p>"크다고" 할 수 있는 정수에는 <code>int64_t</code>를 사용한다.</p>
        <p>표현하려는 내용이 비트 패턴이 아니거나 2의 보수를 정의하는 것이 아니라면 <code>uint32_t</code>와 같은 부호 없는 정수형을 사용해서는 안 된다. 특히 절대 음수가 아닌 수를 표현하는데 부호 없는 정수형을 사용하지 않는다. 대신 이럴 때는 단정문을 사용한다.</p>
        
      </DECISION>

      <SUBSECTION title="On Unsigned Integers">
        <p>교과서 저자를 포함해 일부는 부호 없는 정수형을 사용해 절대 음수가 아닌 수를 표현하는 것을 권한다. 이는 코드 자체로 문서화를 하기 위한 의도이다. 하지만 C에서 그런 문서화 이점보다 이 때문에 생기는 버그가 더 중요하다. 다음을 보자.</p>
        <CODE_SNIPPET>
          for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
        </CODE_SNIPPET>
        <p>이 코드는 절대 종료하지 않는다. 간혹 gcc에서는 이 버그를 알고 경고하지만 대부분은 그렇지 않다. 이와 같은 버그가 부호와 부호 없는 변수를 비교할 때도 생길 수 있다. 기본적으로 C에서 타입 승격은 부호 없는 정수형을 기대한 것과 다르게 동작하게 한다.</p>
        <p>그러므로 변수를 문서화할 때는 단정문을 사용해 음수가 아니라는 것을 나타낸다. 부호 없는 형을 사용하지 않는다.</p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="64-bit Portability">
    <SUMMARY>코드는 64-bit와 32-bit에 적합해야 합니다. printing, 비교 그리고 구조체 정렬의 문제를 명심하십시오.</SUMMARY>
    <BODY>
      <ul>
        <li>
          <p>일부 타입에 대한 <code>printf()</code> 지정자는 32비트와 64비트 시스템 사이에 호환이 명확하지 않다. C99에서는 일부 호환하는 형식 지정자를 정의하고 있다. 불행히도 MSVC 7.1에서는 이 지정자 중 일부를 인식하지 않으며 일부 표준이 빠져 있다. 그러므로 어떤 경우에는 보기 안 좋겠지만 스스로 (<code>inttypes.h</code> 표준 포함 파일 형식으로) 정의해야 한다.</p>
          <CODE_SNIPPET>
            // printf macros for size_t, in the style of inttypes.h
            #ifdef _LP64
            #define __PRIS_PREFIX "z"
            #else
            #define __PRIS_PREFIX
            #endif

            // Use these macros after a % in a printf format string
            // to get correct 32/64 bit behavior, like this:
            // size_t size = records.size();
            // printf("%"PRIuS"\n", size);

            #define PRIdS __PRIS_PREFIX "d"
            #define PRIxS __PRIS_PREFIX "x"
            #define PRIuS __PRIS_PREFIX "u"
            #define PRIXS __PRIS_PREFIX "X"
            #define PRIoS __PRIS_PREFIX "o"
          </CODE_SNIPPET>
          <table border="1" summary="portable printf specifiers">
            <TBODY>
              <tr align="center">
                <th>타입</th>
                <th>사용하지 마시오</th>
                <th>사용하시오</th>
                <th>주의</th>
              </tr>
              <tr align="center">
                <td><code>void *</code> (혹은 다른 포인터)</td>
                <td><code>%lx</code></td>
                <td><code>%p</code></td>
                <td> </td>
              </tr>
              
              <tr align="center">
                <td><code>int64_t</code></td>
                <td><code>%qd</code>, <code>%lld</code></td>
                <td><code>%"PRId64"</code></td>
                <td/>
              </tr>
              
              <tr align="center">
                <td><code>uint64_t</code></td>
                <td><code>%qu</code>, <code>%llu</code>, <code>%llx</code></td>
                <td><code>%"PRIu64"</code>, <code>%"PRIx64"</code></td>
                <td/>
              </tr>
              
              <tr align="center">
                <td><code>size_t</code></td>
                <td><code>%u</code></td>
                <td><code>%"PRIuS"</code>, <code>%"PRIxS"</code></td>
                <td>C99에서 <code>%zu</code> 지정</td>
              </tr>
              <tr align="center">
                <td><code>ptrdiff_t</code></td>
                <td><code>%d</code></td>
                <td><code>%"PRIdS"</code></td>
                <td>C99에서 <code>%zd</code> 지정</td>
              </tr>
              
            </TBODY>
          </table>
          <p><code>PRI*</code> 매크로는 컴파일러에서 연결하는 독립 문자열로 확장하는 것에 주목한다. 그러므로 상수가 아닌 형식 문자열을 사용하면 그 형식 문자열에 이름이 아닌 매크로 값을 넣어야 한다. 일반적으로 <code>PRI*</code> 매크로를 사용할 때 <code>%</code> 다음에 길이 지정자 등을 포함할 수도 있다. 그러므로 <code>printf("x = %30"PRIuS"\n", x)</code>는 32비트 리눅스에서 <code>printf("x = %30" "u" "\n", x)</code>로 확장할 것이고 컴파일러에서는 이를 <code>printf("x = %30u\n", x)</code>로 처리할 것이다.</p>
          
          </li>

        <li><code>sizeof(void *)</code> != <code>sizeof(int)</code>라는 것을 기억한다. 포인터 크기인 정수가 필요하면 <code>intptr_t</code>를 사용한다.</li>

        <li>구조체 정렬에 유의해야 할 수 있다. 특히 디스크에 구조체를 저장하는 경우라면 더 그렇다. <code>int64_t</code>/<code>uint64_t</code>가 멤버로 있는 모든 클래스와 구조체는 기본적으로 64비트 시스템에서 8바이트 경계로 정렬한다. 이런 구조체를 32비트와 64비트 코드에서 디스크를 통해 공유한다면 두 구조에서 모두 같도록 압축해야 한다. 컴파일러 대부분에서는 구조체 정렬을 바꾸는 방법을 제공한다. gcc라면 <code>__attribute__((packed))</code> 를 사용할 수 있다. MSVC에서는 <code>#pragma pack()</code>과 <code>__declspec(align())</code>을 사용한다.</li>

        <li>64비트 상수를 만들 때는 <code>LL</code> 또는 <code>ULL</code> 접미어를 사용한다. 예는 다음과 같다: <CODE_SNIPPET>
             int64_t my_value = 0x123456789LL;
             uint64_t my_mask = 3ULL &lt;&lt; 48;
             </CODE_SNIPPET></li>

        <li>32비트와 64비트 시스템에서 정말로 서로 다른 코드를 써야 한다면 코드가 바뀌는 곳에 <code>#ifdef _LP64</code>를 사용한다(하지만 가능한 이는 피하고 그런 변화는 지역화한다).</li>
      </ul>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Preprocessor Macros">
    <SUMMARY>매크로 사용에 매우 주의하십시오. 매크로 대신에 인라인 함수, 열거형 그리고 <code>const</code> 변수를 더 선호하십시오.</SUMMARY>
    <BODY>
      <p>매크로는 여러분이 보는 코드와 컴파일러가 보는 코드가 다르다는 것을 뜻합니다. 이 때문에 예상하지 못한 결과가 생길 수 있는데 특히 매크로가 전역 범위일 때 더욱 그렇습니다.</p>
      <p>다행히 C++에서 매크로는 C에서와 달리 거의 필요하지 않다. 매크로를 사용하는 대신 성능이 중요한 코드에는 인라인 함수를 사용한다. 상수를 저장하는 매크로를 사용하는 대신 <code>const</code> 변수를 사용한다. 긴 변수 이름을 "줄이기" 위해 매크로를 사용하는 대신 참조를 사용한다. 조건 컴파일 코드를 사용하기 위해 매크로를 사용하는 대신, 음… (물론 헤더 파일을 이중으로 포함하는 것을 막기 위해 <code>#define</code> 보호문을 사용하는 것을 제외하고는) 그렇게는 사용하지 않는다. 그렇게 사용하면 테스트하기가 매우 어려워진다.</p>
      <p>이들 다른 기술로는 할 수 없는 것을 매크로를 사용해 할 수 있으며 코드 베이스, 특히 저수준 라이브러리에서 볼 수 있을 것이다. (문자열로 만들기, 문자열 결합 등) 매크로로 할 수 있는 특별한 기능 중 몇몇은 언어 기능으로 대체할 수 없다. 하지만 매크로를 사용하기 전에 매크로를 사용하지 않고 같은 결과를 얻을 수 없는지 신중히 고려한다.</p>
      <p>다음은 매크로를 사용하며 생기는 많은 문제를 피할 수 있는 사용 방법이다. 그러므로 매크로를 사용한다면 가능한 항상 이를 따른다:</p>
      <ul>
        <li>매크로는 <code>.h</code> 파일에 정의하지 않는다.</li>
        <li>사용하기 바로 직전에 <code>#define</code> 매크로를 사용하고 사용한 후 바로 <code>#undef</code> 한다.</li>
        <li>기존 매크로를 자신이 만든 것으로 대체하려고 <code>#undef</code>로 해제하지 않는다. 대신 유일할 것 같은 이름을 사용한다.</li>
        <li> Try not to use macros that expand to unbalanced C++
             constructs, or at least document that behavior well.
             </li>
        <li><code>##</code>를 사용해 함수, 클래스, 변수 이름을 만들어 내지 않도록 한다.</li>
      </ul>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="0 and nullptr/NULL">
  <SUMMARY>
    Use <code>0</code> for integers, <code>0.0</code> for reals,
    <code>nullptr</code> (or <code>NULL</code>) for pointers,
    and <code>'\0'</code> for chars.
  </SUMMARY>
  <BODY>
    <p>정수에 대해서는 <code>0</code>, 실수에 대해서는 <code>0.0</code>를 사용하십시오. 이것은 논쟁할게 아닙니다.</p>
    <p>
    
    
      For pointers (address values), there is a choice between <code>0</code>
      and <code>NULL</code> (and, for C++11, <code>nullptr</code>).
      For projects that allow C++11 features, use <code>nullptr</code>.
      For C++03 projects, we prefer <code>NULL</code> because it looks like a
      pointer.  In fact, some C++ compilers provide special definitions of
      <code>NULL</code> which enable them to give useful warnings,
      particularly in situations where <code>sizeof(NULL)</code> is not equal
      to <code>sizeof(0)</code>.
    
    </p>
    <p>chars에 대해서 <code>'\0'</code>를 사용하십시오. 이것은 올바른 타입이며 코드를 더 읽기 쉽게 만듭니다.</p>
  </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="sizeof">
  <SUMMARY>가능한 한 <code>sizeof(<var>type</var>)</code> 대신 <code>sizeof(<var>varname</var>)</code>를 사용하십시오.</SUMMARY>
  <BODY>
    <p>변수의 타입이 변경되었을 때 적절히 업데이트될 것이기 때문에 <code>sizeof(<var>varname</var>)</code>를 사용하십시오. 일부 경우에는 <code>sizeof(<var>type</var>)</code>이 합당할 수도 있습니다. 하지만 변수 타입이 변경될 때, 코드 싱크가 실패할 수 있기 때문에 일반적으로 피해야만 합니다.</p>
    <p>
      <CODE_SNIPPET>
        Struct data;
        memset(&amp;data, 0, sizeof(data));
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        memset(&amp;data, 0, sizeof(Struct));
      </BAD_CODE_SNIPPET>
    </p>
  </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="auto">
  <SUMMARY>
    Use <code>auto</code> to avoid type names that are just clutter.
    Continue to use manifest type declarations when it helps readability,
    and never use <code>auto</code> for anything but local variables.
    
  </SUMMARY>
  <BODY>
    <DEFINITION>
      In C++11, a variable whose type is given as <code>auto</code> will be given
      a type that matches that of the expression used to initialize
      it. You can use <code>auto</code> either to initialize a
      variable by copying, or to bind a reference.
        <CODE_SNIPPET>
          vector&lt;string&gt; v;
          ...
          auto s1 = v[0];  // Makes a copy of v[0].
          const auto&amp; s2 = v[0];  // s2 is a reference to v[0].
        </CODE_SNIPPET>
    </DEFINITION>
    <PROS>
      <p>
        C++ type names can sometimes be long and cumbersome,
        especially when they involve templates or namespaces. In a statement like
        <CODE_SNIPPET>
          sparse_hash_map&lt;string, int&gt;::iterator iter = m.find(val);
        </CODE_SNIPPET>
        the return type is hard to read, and obscures the primary
        purpose of the statement. Changing it to
        <CODE_SNIPPET>
          auto iter = m.find(val);
        </CODE_SNIPPET>
        makes it more readable.
      </p>
      <p>
        Without <code>auto</code> we are sometimes forced to write a
        type name twice in the same expression, adding no value
        for the reader, as in
        <CODE_SNIPPET>
          diagnostics::ErrorStatus* status = new diagnostics::ErrorStatus("xyz");
        </CODE_SNIPPET>
      </p>
      <p>
        Using <code>auto</code> makes it easier to use intermediate
        variables when appropriate, by reducing the burden of writing
        their types explicitly.
      </p>
    </PROS>
    <CONS>
      <p>Sometimes code is clearer when types are manifest, especially when
        a variable's initialization depends on things that were declared
        far away. In an expression like
        <CODE_SNIPPET>
          auto i = x.Lookup(key);
        </CODE_SNIPPET>
        it may not be obvious what <code>i</code>'s type is, if <code>x</code>
        was declared hundreds of lines earlier.
      </p>

      <p>Programmers have to understand the difference between <code>auto</code>
        and <code>const auto&amp;</code> or they'll get copies when
        they didn't mean to.
      </p>

      <p>The interaction between <code>auto</code> and C++11
        brace-initialization can be confusing. (C++11 brace-initialization
        isn't an approved feature, but this may become relevant when and
        if it is permitted.) The declarations
        <CODE_SNIPPET>
          auto x(3);  // Note: parentheses.
          auto y{3};  // Note: curly braces.
        </CODE_SNIPPET>
        mean different things — <code>x</code> is
        an <code>int</code>, while <code>y</code> is
        an <code>initializer_list</code>. The same applies to other
        normally-invisible proxy types.
        
      </p>

      <p>If an <code>auto</code> variable is used as part of an
        interface, e.g. as a constant in a header, then a programmer
        might change its type while only intending to change its
        value, leading to a more radical API change than intended.</p>
    </CONS>
    <DECISION>
      <p><code>auto</code> is permitted, for local variables only.
        Do not use <code>auto</code> for file-scope or namespace-scope
        variables, or for class members.</p>
      <p>The <code>auto</code> keyword is also used in an unrelated
        C++11 feature: it's part of the syntax for a new kind of
        function declaration with a trailing return type. Function
        declarations with trailing return types are not permitted.</p>
    </DECISION>
  </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Boost">
  <SUMMARY>Boost 라이브러리 모음에서 승인된 라이브러리들만 사용하라.</SUMMARY>
  <BODY>
    <DEFINITION><a href="http://www.boost.org/">Boost 라이브러리 모음</a>은 상호-검증되고, 무료이며, 오픈-소스인 C++ 라이브러리들의 인기있는 모음이다.</DEFINITION>
    <PROS>부스트 코드는 일반적으로 품질이 매우 높고 호환성이 아주 좋으며 타입 특성(type traits), 더 나은 바인더와 더 나은 스마트 포인터 등과 같이 C++ 표준 라이브러리에 있는 많은 중요한 빈 공간을 메운다. 또한 표준 라이브러리에 TR1 확장 구현도 제공한다.</PROS>
    <CONS>메타 프로그래밍과 고급 템플릿 기술, 과도한 "함수형" 프로그래밍과 같은 일부 부스트 라이브러리에서 사용하는 코드 작성 방법은 가독성을 떨어뜨릴 수 있다.</CONS>
    <DECISION>
      
      <div>코드를 읽고 유지할지도 모를 모든 기부자들에 대해서 높은 수준의 가독성을 유지하기 위해서, Boost의 특징들에서 승인된 것들만 허락한다. 다음의 라이브러리들이 승인되었습니다.: <ul><li><a href="http://www.boost.org/libs/utility/call_traits.htm">Call Traits</a> : <code>boost/call_traits.hpp</code></li><li><a href="http://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair</a> : <code>boost/compressed_pair.hpp</code></li><li>C++03 표준(<code>ptr_circular_buffer.hpp</code>와 <code>ptr_unordered*</code>)에 없는 컨테이너에 대한 직렬화와 랩퍼를 제외한 <code>boost/ptr_container</code>의 <a href="http://www.boost.org/libs/ptr_container/">Pointer Container</a></li><li><a href="http://www.boost.org/libs/array/">Array</a> : <code>boost/array.hpp</code></li><li>직렬화(<code>adj_list_serialize.hpp</code>)와 병렬/분산 알고리즘과 데이타 구조(<code>boost/graph/parallel/*</code>와 <code>boost/graph/distributed/*</code>)를 제외한 <code>boost/graph</code>의 <a href="http://www.boost.org/libs/graph/">The Boost Graph Library (BGL)</a></li><li>병렬/분산 속성 맵(<code>boost/property_map/parallel/*</code>)을 제외한 <code>boost/property_map</code>의 <a href="http://www.boost.org/libs/property_map/">Property Map</a></li><li>반복자 정의와 함께 처리하는 <a href="http://www.boost.org/libs/iterator/">Iterator</a> 부분: <code>boost/iterator/iterator_adaptor.hpp</code>, <code>boost/iterator/iterator_facade.hpp</code>, 그리고 <code>boost/function_output_iterator.hpp</code></li></ul> 리스트에 다른 Boost 특징들을 추가하는 것을 적극적으로 고려하고 있습니다. 따라서 이 규칙은 추후에 완화될지도 모릅니다.</div>
    </DECISION>
  </BODY>
  </STYLEPOINT>

  

  <STYLEPOINT title="C++11">
  <SUMMARY>
    Use only approved libraries and language extensions from C++11 (formerly
    known as C++0x).
    
    Consider portability to other environments before
    using C++11 features in your project.
  </SUMMARY>
  <BODY>
    <DEFINITION>C++11은 마지막 ISO C++ 표준입니다. 그것은 언어와 라이브러리 둘 다에서 <a href="http://en.wikipedia.org/wiki/C%2B%2B11">중대한 변경들</a>을 포함하고 있습니다.</DEFINITION>
    <PROS>C++11은 공식적인 표준이 되었습니다. 그리고 최종적으로 대부분의 C++ 컴파일러에 의해서 지원될 것입니다. 그것은 이미 사용하고 있던 몇개의 일반적인 C++ 확장을 표준화시켰습니다. 그리고 몇개의 동작에 대해서 shorthands를 허용합니다. 그리고 몇개의 성능과 안전성의 개선이 있습니다.</PROS>
    <CONS>
      <p>
        The C++11 standard is substantially more complex than its predecessor
        (1,300 pages versus 800 pages), and is
        unfamiliar to many developers.  The long-term effects of some
        features on code readability and maintenance are unknown.  We cannot
        predict when its various features will be implemented uniformly by
        tools that may be of interest (gcc, icc, clang, Eclipse, etc.).
      </p>
      <p><a href="#Boost">Boost</a>와 마찬가지로, 일부 C++11 확장에서 사용하는 코드 작성 방법은 가독성을 떨어뜨린다. for example by removing checked redundancy (such as type names) that may be helpful to readers, or by encouraging template metaprogramming. 기존 구조로 사용할 수 있는 기능과 중복된 것도 있으며 이 때문에 혼란스럽거나 변환 비용이 생길 수 있다.</p>
    </CONS>
    <DECISION>
      Use only C++11 libraries and language features that have been approved
      for use.
      Currently only the following C++11 features are approved:
      <ul>
        <li><code>auto</code> (for local variables only).</li>
        <li>Use of <code>&gt;&gt;</code> with no intervening space to
          close multiple levels of template arguments, as in
          <code>set&lt;list&lt;string&gt;&gt;</code>,
          where C++03 required a space as in
          <code>set&lt;list&lt;string&gt; &gt;</code>.
        </li>
        <li>Range-based
          <code>for</code> loops.</li>
        <li>Use of the <code>LL</code> and <code>ULL</code> suffixes on
          numeric literals to guarantee that their type is at least 64 bits
          wide.</li>
        <li>Variadic macros (but note
          that use of macros is discouraged).</li>
        <li>All of the new STL algorithms in the
          <a href="http://en.cppreference.com/w/cpp/algorithm">&lt;algorithm&gt;</a>
          and <a href="http://en.cppreference.com/w/cpp/numeric">&lt;numeric&gt;</a>
          headers, except for the versions of
          <code>min</code>, <code>max</code>, and <code>minmax</code>
          whose signatures contain initializer lists.</li>
        <li>Use of local types as template parameters.</li>
        <li><code>nullptr</code> and <code>nullptr_t</code>.</li>
      </ul>
      Other features will be approved individually as appropriate.
      Avoid writing code that is incompatible with C++11 (even though it
      works in C++03).
      
    </DECISION>
  </BODY>
  </STYLEPOINT>

</CATEGORY>

<CATEGORY title="Naming">
  <p>가장 중요한 일관성 규칙은 이름을 짓는 것입니다. 이름을 짓는 스타일은 이름 붙은 존재(타입, 변수, 함수, 상수, 매크로 등)의 선언을 찾지 않고도, 해당 타입의 종류를 바로 알 수 있게 해줍니다. 우리 머리속에 있는 패턴-일치 엔진은 이러한 이름 규칙에 매우 많이 의존하고 있습니다.</p>
  <p>이름 규칙은 꽤 임의적이지만 개인적인 선호보다는 일관성이 더 중료하다고 생각합니다. 그러므로 그것이 합리적이라고 생각하든 그렇지 않든 규칙은 규칙입니다.</p>

  <STYLEPOINT title="General Naming Rules">
    <SUMMARY>함수 이름, 변수 이름 그리고 파일명은 서술적이여야만 합니다; 약어형태를 피하십시오. 함수가 "command" 동사여야만 하는데 반해서 타입과 변수들은 명사여야만 합니다, </SUMMARY>
    <BODY>
      <SUBSECTION title="How to Name">
        <p>이름은 가능한 이유를 담아 설명적이어야 한다. 코드를 즉시 이해하는 게 더 중요하므로 수평 공간을 절약하는 것으로 걱정하지 말라. 다음은 잘 선택한 이름 예이다.</p>
        <CODE_SNIPPET>
          int num_errors;                  // Good.
          int num_completed_connections;   // Good.
        </CODE_SNIPPET>
        <p>의미를 담지 않고 모호하게 축약하거나 임의 문자를 이름으로 쓰는 것은 잘못된 선택이다.</p>
        <BAD_CODE_SNIPPET>
          int n;                           // Bad - meaningless.
          int nerr;                        // Bad - ambiguous abbreviation.
          int n_comp_conns;                // Bad - ambiguous abbreviation.
        </BAD_CODE_SNIPPET>
        <p>타입과 변수 이름은 일반적으로 명사여야만 합니다: 예를 들면, <code>FileOpener</code>, <code>num_errors</code>.</p>
        <p>함수 이름은 <code>OpenFile()</code>, <code>set_num_errors()</code>처럼 전형적으로 명령적이어야 한다(즉 명령이어야 한다). 예외로 접근자는 접근하는 변수 이름과 같아야 한다. 이에 대해서는 <a HREF="#Function_Names">함수 이름들</a>에서 더 자세히 설명한다.</p>
      </SUBSECTION>

      <SUBSECTION title="Abbreviations">
        <p>프로젝트 외에서 잘 알려져 있지 않으면 약어를 사용하지 않는다. 예를 들면 다음과 같다.</p>
        <CODE_SNIPPET>
          // Good
          // These show proper names with no abbreviations.
          int num_dns_connections;  // Most people know what "DNS" stands for.
          int price_count_reader;   // OK, price count. Makes sense.
        </CODE_SNIPPET>
        <BAD_CODE_SNIPPET>
          // Bad!
          // Abbreviations can be confusing or ambiguous outside a small group.
          int wgc_connections;  // Only your group knows what this stands for.
          int pc_reader;        // Lots of things can be abbreviated "pc".
        </BAD_CODE_SNIPPET>
        <p>절대로 글자를 빠뜨려 축약하지 않아야 한다.</p>
        <CODE_SNIPPET>
          int error_count;  // Good.
        </CODE_SNIPPET>
        <BAD_CODE_SNIPPET>
          int error_cnt;    // Bad.
        </BAD_CODE_SNIPPET>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="File Names">
    <SUMMARY>파일 이름은 모두 소문자여야 합니다. 그리고 언더스코어(<code>_</code>)나 대쉬(<code>-</code>)를 포함할 수 있습니다. 프로젝트에서 사용하는 관례를 따르십시오. 만약 따르는 일관성있는 로컬 패턴이 없다면, "_"를 선호하십시오.</SUMMARY>
    <BODY>
      <p>허용 가능한 파일 이름의 예제들:</p>
      <p>
        <code>my_useful_class.cc<br/> my-useful-class.cc<br/> myusefulclass.cc<br/> myusefulclass_test.cc // _unittest and _regtest are deprecated.<br/></code>
      </p>
      <p>C++ 파일은 <code>.cc</code>로 끝나야 하고, 헤더 파일은 <code>.h</code>로 끝나야만 합니다.</p>
      <p><code>db.h</code> 같이 <code>/usr/include</code>에 이미 존재하는 파일 이름들을 사용하지 마십시오.</p>
      <p>일반적으로, 파일 이름을 매우 특별하게 만드십시오. 예를 들면, <code>logs.h</code>보다는 <code>http_server_logs.h</code>를 사용하십시오. <code>FooBar</code>라고 불리는 클래스를 정의하는 <code>foo_bar.h</code>와 <code>foo_bar.cc</code>라는 파일의 쌍을 가지는 것은 매우 일반적인 경우입니다.</p>
      <p>인라인 함수는 반드시 <code>.h</code> 파일에 있어야만 합니다. 만약 인라인 함수가 매우 짧다면, <code>.h</code> 파일에 바로 들어가야 합니다. 그러나, 만약 인라인 함수가 많은 코드를 포함하고 있다면, <code>-inl.h</code>로 끝나는 별도의 파일에 들어갈 지도 모릅니다. 많은 인라인 코드를 가지고 있는 클래스의 경우에, 클래스는 다음의 세개의 파일을 가질 것입니다:</p>
      <CODE_SNIPPET>
        url_table.h      // The class declaration.
        url_table.cc     // The class definition.
        url_table-inl.h  // Inline functions that include lots of code.
      </CODE_SNIPPET>
      <p>또한 <a href="#The_-inl.h_Files">-inl.h 파일들</a> 섹션을 참고 하십시오</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Type Names">
    <SUMMARY>타입 이름은 대문자로 시작하고 각각의 새로운 단어는 언더스코어 없이 대문자로 시작합니다: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</SUMMARY>
    <BODY>
      <p>
        The names of all types — classes, structs, typedefs, and enums
        — have the same naming convention.  Type names should start
        with a capital letter and have a capital letter for each new
        word.  No underscores.  For example:
      </p>
      <CODE_SNIPPET>
        // classes and structs
        class UrlTable { ...
        class UrlTableTester { ...
        struct UrlTableProperties { ...

        // typedefs
        typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

        // enums
        enum UrlTableErrors { ...
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Variable Names">
    <SUMMARY>변수 이름은 단어 사이를 언더스코어로 한 소문자 입니다. 클래스 멤버 변수는 끝에 언더스코어 문자를 가집니다. 예를 들면: <code>my_exciting_local_variable</code>, <code>my_exciting_member_variable_</code>.</SUMMARY>
    <BODY>
      <SUBSECTION title="Common Variable names">
        <p>예제:</p>
        <CODE_SNIPPET>
          string table_name;  // OK - uses underscore.
          string tablename;   // OK - all lowercase.
        </CODE_SNIPPET>
        <BAD_CODE_SNIPPET>
          string tableName;   // Bad - mixed case.
        </BAD_CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Class Data Members">
        <p>데이타 멤버들(또한 인스턴스 변수 혹은 멤버 변수라고 불리는)은 일반적인 변수 이름과 같이 부가적인 언더스코어를 가지는 소문자입니다. 하지만 끝은 항상 언더스코어로 끝나야 합니다.</p>
        <CODE_SNIPPET>
          string table_name_;  // OK - underscore at end.
          string tablename_;   // OK.
        </CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Struct Variables">
        <p>구조체의 데이타 멤버는 클래스의 데이터 멤버가 가지는 끝의 언더스코어 없이 일반 변수와 같이 이름이 붙습니다.</p>
        <CODE_SNIPPET>
          struct UrlTableProperties {
            string name;
            int num_entries;
          }
        </CODE_SNIPPET>
        <p>구조체와 클래스를 사용할 때의 토론에 대해서는 <a HREF="#Structs_vs._Classes">구조체 대 클래스</a>를 보십시오.</p>
      </SUBSECTION>

      <SUBSECTION title="Global Variables">
        <p>전역 변수에 대해서는 특별한 요구사항(대소문자에 대한 요구사항 같은)이 없습니다. 하지만 지역 변수와 쉽게 비교되기 위해서 <code>g_</code> 혹은 다른 마커를 앞에 붙이는 것을 고려해 보십시오.</p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Constant Names">
    <SUMMARY>대소문자가 혼합된 형태의 앞에 <code>k</code> 문자를 사용하십시오: <code>kDaysInAWeek</code>.</SUMMARY>
    <BODY>
      <p>모든 컴파일 타임의 상수(지역적이든 전역적이든, 혹은 클래스의 일부던지)는 다른 변수의 이름 짓기 규칙과는 조금 다릅니다. 첫 번째 문자가 대문자인 단어의 앞에 <code>k</code> 문자를 사용하십시오:</p>
      <CODE_SNIPPET>
        const int kDaysInAWeek = 7;
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Names">
    <SUMMARY>일반 함수들은 대소문자가 섞인 이름을 가집니다. 접근자와 수정자는 변수 이름과 일치하는 이름을 가집니다: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</SUMMARY>
    <BODY>
      <SUBSECTION title="Regular Functions">
        <p>함수는 대문자로 시작해야만 합니다. 그리고 각각의 새로운 단어에서 대문자로 시작합니다. 언더스코어 문자는 없습니다.</p>
        <p>만약 함수가 에러가 발생했을 때 크래쉬 된다면, 함수 이름에 OrDie를 추가해야만 합니다. 이것은 제품 코드에 의해서 사용될 수 있는 함수와 일반적인 동작중에 발생하는 합당한 에러에 대해서만 적용됩니다.</p>
        <CODE_SNIPPET>
          AddTableEntry()
          DeleteUrl()
          OpenFileOrDie()
        </CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Accessors and Mutators">
        <p>접근자와 수정자(get과 set 함수들)는 그들이 get/set하는 변수 이름과 일치해야만 합니다. 다음은 인스턴스 변수 <code>num_entries_</code>를 가지는 클래스에 대한 예를 보여줍니다.</p>
        <CODE_SNIPPET>
          class MyClass {
           public:
            ...
            int num_entries() const { return num_entries_; }
            void set_num_entries(int num_entries) { num_entries_ = num_entries; }

           private:
            int num_entries_;
          };
        </CODE_SNIPPET>
        <p>매우 짧은 inline된 함수의 이름에 대해서 소문자를 사용할 지도 모릅니다. 예를 들면, 루프에서 호출하면서 그 값을 캐시하지 않을 정도로 작다면, 소문자 이름도 허용됩니다.</p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Namespace Names">
    
    <SUMMARY>네임스페이스 이름은 모두 소문자입니다. 그리고 프로젝트 이름과 가능하면 그들의 디렉토리 구조에 기반해야 합니다: <code>google_awesome_project</code>.</SUMMARY>
    <BODY>
      <p>네임스페이스에 대한 토의와 어떻게 이름 짓는지에 대해서 <a HREF="#Namespaces">네임스페이스</a>를 보십시오.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Enumerator Names">
    <SUMMARY>열거형은 <A HREF="#Constant_Names">constants</A> 혹은 <A HREF="#Macro_Names">macros</A>, 둘 중에 하나(<i>either</i>)처럼 이름지어져야 합니다.: <code>kEnumName</code> 혹은 <code>ENUM_NAME</code>.</SUMMARY>
    <BODY>
      <p>오히려, 개개의 열거형 값은 <A HREF="#Constant_Names">constants</A>처럼 이름지어져야만 합니다. 그러나 <A HREF="#Macro_Names">macros</A>처럼 이름 짓는 것도 허용 가능합니다. 열거형 이름 <code>UrlTableErrors</code>와 <code>AlternateUrlTableErrors</code>는 타입입니다. 따라서 대소문자가 섞여있습니다.</p>
      <CODE_SNIPPET>
        enum UrlTableErrors {
          kOK = 0,
          kErrorOutOfMemory,
          kErrorMalformedInput,
        };
        enum AlternateUrlTableErrors {
          OK = 0,
          OUT_OF_MEMORY = 1,
          MALFORMED_INPUT = 2,
        };
      </CODE_SNIPPET>
      <p>2009년 1월까지는, 열거형 값을 <A HREF="#Macro_Names">macros</A>처럼 이름을 짓는 것이 스타일이었습니다. 그러나 이것은 열거형 값과 매크로 사이에 이름 충돌의 문제를 야기했습니다. 따라서 상수 스타일로 이름 짓는 것을 더 선호하는 것으로 변경되었습니다. 새로운 코드는 가능한한 상수 스타일의 이름을 가져야 합니다. 그러나 예전 이름이 실제적으로 컴파일-타임 문제를 야기하지 않는다면, 예전 코드의 상수 스타일의 이름을 변경할 이유는 없습니다.</p>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Macro Names">
    <SUMMARY>정말로는 <A HREF="#Preprocessor_Macros">매크로 정의</A>를 하지 않을 것입니다. 그렇지 않습니까? 만약 매크로를 정의한다면, 다음과 같이 하십시오: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</SUMMARY>
    <BODY>
      <p><a href="#Preprocessor_Macros">매크로 설정</a>을 보십시오; 일반적으로 매크로는 사용되지 말아야만 합니다(<em>not</em>). 그러나, 만약 절대적으로 필요하다면, 모두 대문자와 언더스코어 문자로 이름지어져야만 합니다.</p>
      <CODE_SNIPPET>
        #define ROUND(x) ...
        #define PI_ROUNDED 3.0
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Exceptions to Naming Rules">
    <SUMMARY>만약 C 혹은 C++ 엔트리에 존재하는 것과 유사한 어떤것의 이름을 지어야 한다면 존재하는 이름짓기 관례를 따를 수 있습니다.</SUMMARY>
    <BODY>
      <p>
        <dl>
          <dt> <code>bigopen()</code> </dt>
          <dd>   function name, follows form of <code>open()</code> </dd>
          <dt> <code>uint</code> </dt>
          <dd>   <code>typedef</code> </dd>
          <dt> <code>bigpos</code> </dt>
          <dd>   <code>struct</code> or <code>class</code>, follows form of
                 <code>pos</code> </dd>
          <dt> <code>sparse_hash_map</code> </dt>
          <dd>   STL-like entity; follows STL naming conventions </dd>
          <dt> <code>LONGLONG_MAX</code> </dt>
          <dd>   a constant, as in <code>INT_MAX</code> </dd>
        </dl>
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Comments">
  <p>글 쓰는게 고통스러울지라도 주석문은 코드 가독성을 좋게 유지하는데 절대적으로 중요합니다. 다음 규칙에서는 무엇을, 어디에 적어야 하는지 설명합니다. 하지만 기억해 둘 것은, 주석문이 아무리 중요할지라도 좋은 코드는 그 자체로 문서라는 점입니다. 타입과 변수에 적절한 이름을 사용하는 것이 불명확한 이름을 사용해 그에 대한 설명을 해야 하는 것보다는 더 좋습니다.</p>
  <p>
    When writing your comments, write for your audience: the next
    
    contributor
    who will need to understand your code.  Be generous — the next
    one may be you!
  </p>

  <STYLEPOINT title="Comment Style">
    <SUMMARY>일관성을 유지하는한 <code>//</code> 혹은 <code>/* */</code> 구문중에 하나를 사용하십시오.</SUMMARY>
    <BODY>
      <p><code>//</code> 또는 <code>/* */</code> 문법 중 하나를 사용할 수 있다. 하지만 <code>//</code>가 훨씬 더(<em>much</em>) 일반적이다. 주석문을 적는 방법과 사용하는 형식을 일관되게 유지한다.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="File Comments">
    <SUMMARY>
      Start each file with license boilerplate,
      followed by a description of its contents.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Legal Notice and Author Line">
        
        <p>
          Every file should contain license boilerplate.
          Choose the appropriate boilerplate for the license used by the project
          (for example, Apache 2.0, BSD, LGPL, GPL).
        </p>
        <p>
          If you make significant changes to a file with an author line,
          consider deleting the author line.
        </p>
      </SUBSECTION>

      <SUBSECTION title="File Contents">
        <p>
          Every file should have a comment at the top describing its contents.
        </p>
        <p>일반적으로 <code>.h</code> 파일은 파일에서 선언한 클래스와 무엇을 하고 어떻게 사용되는지에 대한 대략적인 내용을 설명합니다. <code>.cc</code> 파일은 구현에 대한 상세한 정보나 까다로운 알고리즘에 대한 더 많은 내용을 가져야만 합니다. 구현에 대한 상세한 정보나 알고리즘에 대한 내용이 <code>.h</code> 파일을 읽는 사람에서 유용하다면, 구현에 대한 상세한 정보나 알고리즘에 대한 내용을 그리고 옮겨도 됩니다. 하지만 <code>.h</code> 파일에 문서화 내용이 들어있다는 것을 <code>.cc</code> 파일에 업급하십시오.</p>
        <p>같은 주석을 <code>.h</code>와 <code>.cc</code>에 중복해서 넣지 마십시오. 중복된 주석도 달라집니다.</p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Class Comments">
    <SUMMARY>모든 클래스 정의는 클래스가 무엇을 위한 것이고 어떻게 사용되어져야만 하는지에 대한 주석을 가져야만 합니다.</SUMMARY>
    <BODY>
      <CODE_SNIPPET>
        // Iterates over the contents of a GargantuanTable.  Sample usage:
        //    GargantuanTableIterator* iter = table-&gt;NewIterator();
        //    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
        //      process(iter-&gt;key(), iter-&gt;value());
        //    }
        //    delete iter;
        class GargantuanTableIterator {
          ...
        };
      </CODE_SNIPPET>
      <p>파일 상단 주석문에서 클래스에 대해 이미 설명을 했다면 "자세한 설명은 파일 상단 주석문을 참조한다."라는 내용으로 자유롭게 간단히 적는다.</p>
      <p>클래스를 만들 때 한 동기화 가정이 있으면 문서화한다. 여러 스레드에서 해당 클래스 인스턴스에 접근한다면 다중 스레드 환경에서 규칙과 불변 내용에 대해 주의를 더 기울여 문서화한다.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Comments">
    <SUMMARY>선언 주석은 함수의 사용법을 설명합니다. 함수의 정의에 있는 주석은 함수의 동작을 설명합니다.</SUMMARY>
    <BODY>
      <SUBSECTION title="Function Declarations">
        <p>모든 함수 선언에는 바로 앞에 해당 함수의 목적과 사용 방법을 설명하는 주석문이 있어야 한다. 이 주석문는 명령적("파일을 열어라")이기보다 설명적("파일을 연다")이어야 한다. 즉 이 주석문은 함수를 설명하는 것이지 할 일을 함수에 알리는 것이 아니다. 일반적으로 이 주석문은 함수가 일을 어떻게 처리하는지 설명하지 않는다. 그런 내용은 함수 정의에서 사용하는 주석문에 둔다.</p>
        <p>다음은 함수 선언에 있는 주석문에서 언급해야 할 것들이다.</p>
        <ul>
          <li>입력과 출력은 무엇인지</li>
          <li>클래스 멤버 함수에 대한 내용. 즉 메소드 호출 기간을 지나서도 참조 인자를 해당 객체에서 기억해야 하는지 아니면 해제할지 말지 등.</li>
          <li>호출하는 쪽에서 꼭 해제해야 하는 메모리를 해당 함수에서 할당하는지</li>
          <li> Whether any of the arguments can be a null pointer.
               </li>
          <li>함수 사용 방법에 따라 성능에 영향이 있는지</li>
          <li>함수에 재진입 할 수 있는지. 동기화 가정은 무엇인지.</li>
        </ul>
        <p>다음은 그 예입니다:</p>
        <CODE_SNIPPET>
          // Returns an iterator for this table.  It is the client's
          // responsibility to delete the iterator when it is done with it,
          // and it must not use the iterator once the GargantuanTable object
          // on which the iterator was created has been deleted.
          //
          // The iterator is initially positioned at the beginning of the table.
          //
          // This method is equivalent to:
          //    Iterator* iter = table-&gt;NewIterator();
          //    iter-&gt;Seek("");
          //    return iter;
          // If you are going to immediately seek to another place in the
          // returned iterator, it will be faster to use NewIterator()
          // and avoid the extra seek.
          Iterator* GetIterator() const;
        </CODE_SNIPPET>
        <p>하지만 필요 이상으로 장황하거나 아주 분명한 것을 적지 않도록 한다. 다음에서는 "조건에 맞지 않으면 거짓을 반환한다"는 것을 알 수 있으므로 그런 내용을 적을 필요 없다.</p>
        <CODE_SNIPPET>
          // Returns true if the table cannot hold any more entries.
          bool IsTableFull();
        </CODE_SNIPPET>
        <p>생성자와 소멸자에 주석을 달 때는, 생성자와 소멸자가 무엇을 위한 것인지는 알고 있으므로 단순히 "이 객체를 소멸한다"라는 식으로 적는 건 쓸모 없다. (예를 들어 인자에서 포인터 소유권을 취한다면) 생성자에서 그 인자로 무엇을 하는지, 소멸자에서 무엇을 제거하는지를 문서화한다. 이런 내용이 중요하지 않으면 문서화하지 않는다. 소멸자 앞에 주석문을 두지 않는 것은 꽤 일반적이다.</p>
      </SUBSECTION>

      <SUBSECTION title="Function Definitions">
        <p>각 함수 정의에는 함수에서 일을 처리하는 방법에 관한 기술적인 무언가가 있으면 그에 대해 설명하는 주석문이 있어야 한다. 즉 정의 주석문에서는 사용하는 코딩 기술, 거쳐야 할 단계에 대한 개략적인 내용 또는 다른 방법 대신 왜 그 방법으로 구현했는지 설명할 수 있다. 예를 들어 함수 전반부 동안은 락을 걸어야 하지만 왜 후반부 동안은 그럴 필요가 없는지를 언급할 수 있다.</p>
        <p>단순히 <code>.h</code> 파일 등 함수 선언에서 적은 내용을 반복하지 않도록(<em>not</em>) 주의해야 한다. 함수가 하는 일을 간략히 요약하는 것은 괜찮으나 주석문 내용은 어떻게 처리하는지에 초점을 맞춰야 한다.</p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Variable Comments">
    <SUMMARY>일반적으로 변수의 실제 이름은 변수가 무엇을 위해 사용되는지에 대한 좋은 아이디어를 주기에 충분할 정도로 설명적이어야 합니다. 특정 경우에는 더 많은 주석이 필요합니다.</SUMMARY>
    <BODY>
      <SUBSECTION title="Class Data Members">
        <p>
          Each class data member (also called an instance variable or
          member variable) should have a comment describing what it is
          used for.  If the variable can take sentinel values with
          special meanings, such as a null pointer or -1, document this.
          For example:
        </p>
        <CODE_SNIPPET>
          private:
           // Keeps track of the total number of entries in the table.
           // Used to ensure we do not go over the limit. -1 means
           // that we don't yet know how many entries the table has.
           int num_total_entries_;
        </CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Global Variables">
        <p>데이터 멤버와 마찬가지로 모든 전역 변수에는 그 변수가 무엇이고 무엇을 위해 사용하는지 설명하는 주석문이 있어야 한다. 예를 보자.:</p>
        <CODE_SNIPPET>
          // The total number of tests cases that we run through in this regression test.
          const int kNumTestCases = 6;
        </CODE_SNIPPET>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Implementation Comments">
    <SUMMARY>구현에서 코드가 까다롭거나, 명백하지 않거나, 흥미롭거나 혹은 중요한 부분에 주석을 가져야만 합니다.</SUMMARY>
    <BODY>
      <SUBSECTION title="Class Data Members">
        <p>까다롭거나 복잡한 코드 블럭은 그 전에 주석을 가져야만 합니다. 예를 들면:</p>
        <CODE_SNIPPET>
          // Divide result by two, taking into account that x
          // contains the carry from the add.
          for (int i = 0; i &lt; result-&gt;size(); i++) {
            x = (x &lt;&lt; 8) + (*result)[i];
            (*result)[i] = x &gt;&gt; 1;
            x &amp;= 1;
          }
        </CODE_SNIPPET>
      </SUBSECTION>
      <SUBSECTION title="Line Comments">
        <p>또한, 명확하지 않은 라인들은 라인 끝에 주석을 가져야만 합니다. 이 라인-끝 주석은 코드에서 두개의 스페이스로 분리되어있어야만 합니다. 예를 들면:</p>
        <CODE_SNIPPET>
          // If we have enough memory, mmap the data portion too.
          mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
          if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
            return;  // Error already logged.
        </CODE_SNIPPET>
        <p>코드가 무엇을 하고 있는지를 설명하는 주석과, 함수가 반환할 때 에러가 이미 로그되었음을 설명하는 주석, 둘 다 있다는 것을 주의하십시오.</p>
        <p>연속된 줄에 몇개의 주석이 있을 때, 줄을 맞추면 종종 가독성이 더 좋아진다:</p>
        <CODE_SNIPPET>
          DoSomething();                  // Comment here so the comments line up.
          DoSomethingElseThatIsLonger();  // Comment here so there are two spaces between
                                          // the code and the comment.
          { // One space before comment when opening a new scope is allowed,
            // thus the comment lines up with the following comments and code.
            DoSomethingElse();  // Two spaces before line comments normally.
          }
        </CODE_SNIPPET>
      </SUBSECTION>
      <SUBSECTION title="nullptr/NULL, true/false, 1, 2, 3...">
        <p>
          When you pass in a null pointer, boolean, or literal integer
          values to functions, you should consider adding a comment about
          what they are, or make your code self-documenting by using
          constants. For example, compare:
        </p>
        <BAD_CODE_SNIPPET>
          bool success = CalculateSomething(interesting_value,
                                            10,
                                            false,
                                            NULL);  // What are these arguments??
        </BAD_CODE_SNIPPET>
        <p>
          versus:
        </p>
        <CODE_SNIPPET>
          bool success = CalculateSomething(interesting_value,
                                            10,     // Default base value.
                                            false,  // Not the first time we're calling this.
                                            NULL);  // No callback.
        </CODE_SNIPPET>
        <p>혹은, 상수나 스스로 설명이 가능한 변수들:</p>
        <CODE_SNIPPET>
          const int kDefaultBaseValue = 10;
          const bool kFirstTimeCalling = false;
          Callback *null_callback = NULL;
          bool success = CalculateSomething(interesting_value,
                                            kDefaultBaseValue,
                                            kFirstTimeCalling,
                                            null_callback);
        </CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Don'ts">
        <p>절대로 코드 자체를 설명해서는 안됩니다(<em>never</em>). 코드를 읽는 사람이 당신이 무엇을 하려고 했는지 모를지라도, 당신보다 C++에 대해서 더 잘 안다고 가정하십시오.</p>
        <BAD_CODE_SNIPPET>
           // Now go through the b array and make sure that if i occurs,
           // the next element is i+1.
           ...        // Geez.  What a useless comment.
        </BAD_CODE_SNIPPET>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Punctuation, Spelling and Grammar">
    <SUMMARY>구두법, 스펠링 그리고 문법에 주의를 기울이십시오; 잘 쓰여진 주석이 잘못 쓰여진 주석보다 더 읽기 쉽습니다.</SUMMARY>
    <BODY>
      <p>
        Comments should be as readable as narrative text, with proper
        capitalization and punctuation. In many cases, complete sentences are
        more readable than sentence fragments. Shorter comments, such as
        comments at the end of a line of code, can sometimes be less formal, but
        you should be consistent with your style.
      </p>
      <p>비록 코드 검수자가 세미콜론를 써야 할 곳에 쉼표를 썼다고 지적해 기가 꺾일지라도 소스 코드의 명확성과 가독성을 높은 수준으로 유지하는 것은 매우 중요하다. 올바른 구두점, 맞춤법 그리고 문법은 이런 목표를 이루는데 도움이 된다.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="TODO Comments">
    <SUMMARY>코드가 임시적이거나, 짧은 기간동안의 해결책이거나, 충분히 좋은 코드지만 완벽하지 않은 경우에 <code>TODO</code> 주석을 사용하십시오.</SUMMARY>
    <BODY>
      <p><code>TODO</code> 주석문에는 모두 대문자로 쓴 <code>TODO</code> 문자열, <code>TODO</code> 내용에 관련된 문제에 대한 상황을 가장 잘 알려줄 수 있는 이의 이름, 이메일 주소 또는 누군지 식별할 수 있는 다른 내용이 있어야 한다. <code>TODO</code> 형식을 일관되게 유지하는 주된 이유는 요청에 대해 더욱 자세한 내용을 알려줄 수 있는 이를 검색해 찾을 수 있도록 하기 위해서이다. <code>TODO</code>는 언급된 이가 그 문제를 해결할 거라는 공약이 아니다. 따라서 <code>TODO</code>를 만들면 거의 항상 자신의 이름을 적는다.</p>
      
      <CODE_SNIPPET>
        // TODO(kl@gmail.com): Use a "*" here for concatenation operator.
        // TODO(Zeke) change this to use relations.
      </CODE_SNIPPET>
      <p><code>TODO</code>를 "미래에 무언가를 할 것"이라는 형식으로 만든다면 정확한 날짜("2005년 11월까지 수정")나 정확한 시기("모든 클라이언트가 XML 응답을 처리할 수 있을 때 이 코드를 삭제") 중 하나를 포함했는지 확인한다.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Deprecation Comments">
    <SUMMARY>더 이상 사용하면 안되는 인터페이스 위치를 <code>DEPRECATED</code> 주석으로 마크하십시오.</SUMMARY>
    <BODY>
      <p>모두 대문자로 쓴 <code>DEPRECATED</code>란 단어를 주석문에 포함해 앞으로 비추천 인터페이스로 표시할 수 있다. 이 주석문은 해당 인터페이스 선언 앞 또는 그 선언과 같은 줄에 둔다.</p>
      
      <p><code>DEPRECATED</code> 다음에는 이름과 이메일 주소 또는 누군지 식별할 수 있는 다른 내용을 괄호 안에 적는다.</p>
      <p>비추천 주석문에는 다른 이가 호출 내용을 수정할 수 있도록 간단하고 명확한 지시 내용을 포함해야 한다. C++에서는 새 인터페이스를 호출하는 인라인 함수로 비추천 함수를 구현할 수 있다.</p>
      <p>인터페이스 지점을 <code>DEPRECATED</code>로 표시한다고 해서 마법처럼 호출 내용이 바뀌는 것은 아니다. 비추천하는 기능을 실제로 사용하지 않기를 원한다면 호출 내용을 직접 수정하거나 도와줄 팀원을 구해야 할 것이다.</p>
      <p>새로 만드는 코드에서는 비추천 인터페이스를 호출하지 않고 대신 새 인터페이스를 사용해야 한다. 지시 내용을 이해할 수 없으면 비추천 내용을 적은 이를 찾아 새 인터페이스를 사용할 수 있도록 도움을 요청한다.</p>
      
    </BODY>
  </STYLEPOINT>

</CATEGORY>

<CATEGORY title="Formatting">
  <p>코드 스타일과 형식은 꽤 임의적이지만 모든 이가 같은 스타일을 사용하면 프로젝트는 훨씬 쉬워진다. 모든 이가 모든 형식 규칙에 동의하지 않을 수 있고 규칙 중 일부는 다소 익숙할 수도 있다. 하지만 중요한 것은 프로젝트의 모든 기여자가 같은 스타일을 따라야 다른 이가 만든 코드를 쉽게 읽고 이해할 수 있다는 점이다.</p>
  
  <p>정확하게 코드를 포멧팅하는 것을 돕기 위해서 <A HREF="http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el">emacs를 위한 설정 파일</A>를 만들어 두었습니다.</p>

  <STYLEPOINT title="Line Length">
    <SUMMARY>코드의 텍스트의 각 라인은 많아야 80 문자 길이여야 합니다.</SUMMARY>
    <BODY>
      
      <p>이 규칙의 논쟁의 여지가 있다는 것을 알고 있습니다. 하지만 기존에 존재하던 많은 코드가 이미 이 규칙을 따르고 있고, 일관성을 유지하는 것은 중요하다고 생각합니다.</p>
      <PROS>이 규칙을 지지하는 이들은 창 크기를 조절하도록 강제하고 어느 것도 그 제한을 넘지 않도록 하는 게 간편하다고 주장한다. 일부는 코드 창을 나란히 띄워 사용하므로 창을 더 넓게 배치할 공간이 없다. 사람들은 자신의 작업 환경을 구성할 때 최대 창 폭을 특정 값으로 가정하며 80 열은 전통적으로 표준이다. 바꿀 이유가 있을까?</PROS>
      <CONS>바꿀 것을 지지하는 쪽은 줄 폭이 더 넓으면 가독성이 더 좋아진다고 주장한다. 80 열 제한은 완고했던 1960년대 메인프레임 시절로 돌아가는 것이다. 현대 장비에는 더 긴 줄 내용을 넓은 화면에 쉽게 보여줄 수 있는 넓은 화면이 있다.</CONS>
      <DECISION>
        <p>80개의 문자가 최대값입니다.</p>
        <p>예외: 주석이 80 문자보다 큰 예제 명령이나 URL을 포함하고 있다면, 해당 라인은 복사/붙여넣기가 쉽도록 80 문자 이상이 될 수도 있습니다.</p>
        <p>예외: 80열을 넘을지도 모를 긴 경로를 가지는 <code>#include</code> 문의 경우. 이러한 것이 필요한 상황을 피하도록 하십시오.</p>
        <p>예외: 최대 길이를 넘는 <a href="#The__define_Guard">헤더 가드</a>에 대해서는 고려할 필요가 없습니다.</p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Non-ASCII Characters">
    <SUMMARY>Non-ASCII 문자는 적게 사용해야 하고, UTF-8 포멧팅을 사용해야만 합니다.</SUMMARY>
    <BODY>
      <p>
        You shouldn't hard-code user-facing text in source, even English,
        so use of non-ASCII characters should be rare.  However, in certain
        cases it is appropriate to include such words in your code.  For
        example, if your code parses data files from foreign sources,
        it may be appropriate to hard-code the non-ASCII string(s) used in
        those data files as delimiters.  More commonly, unittest code
        (which does not
        
        need to be localized) might contain non-ASCII strings.  In such
        cases, you should use UTF-8, since that is
        
        an encoding understood by most tools able
        to handle more than just ASCII.
        Hex encoding is also OK, and encouraged where it enhances
        readability — for example, <code>"\xEF\xBB\xBF"</code> is the
        Unicode zero-width no-break space character, which would be
        invisible if included in the source as straight UTF-8.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Spaces vs. Tabs">
    <SUMMARY>공백만 사용하십시오. 그리고 한번에 두개의 스페이스로 인덴트하십시오.</SUMMARY>
    <BODY>
      <p>indent를 위해서 스페이스를 사용합니다. 코드에서 탭을 사용하지 마십시오. 탭키를 누를때 스페이스로 변경하도록 편집기를 설정해야만 합니다.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Declarations and Definitions">
    <SUMMARY>함수 이름과 같은 라인에 반환값을 명시하십시오. 충분하다면 파라메터도 같은 라인에 명시하십시오.</SUMMARY>
    <BODY>
      <p>함수는 다음처럼 보일 것입니다.:</p>
      <CODE_SNIPPET>
        ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
          DoSomething();
          ...
        }
      </CODE_SNIPPET>
      <p>만약 한 라인에 넣기에 너무 텍스트가 많다면:</p>
      <CODE_SNIPPET>
        ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                                     Type par_name3) {
          DoSomething();
          ...
        }
      </CODE_SNIPPET>
      <p>혹은 첫번째 파라메터도 넣을 수 없다면:</p>
      <CODE_SNIPPET>
        ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
            Type par_name1,  // 4 space indent
            Type par_name2,
            Type par_name3) {
          DoSomething();  // 2 space indent
          ...
        }
      </CODE_SNIPPET>
      <p>몇 가지 주의할 내용은 다음과 같다.</p>
      <ul>
        <li>리턴 타입은 함수 이름과 항상 같은 라인에 옵니다.</li>
        <li>열린 괄호는 함수 이름과 항상 같은 라인에 옵니다.</li>
        <li>함수 이름과 열린 괄호 사이에는 스페이스가 절대로 없습니다.</li>
        <li>괄호와 파라메터 사이에는 스페이스가 절대로 없습니다.</li>
        <li>열린 중괄호는 항상 마지막 파라메터와 같은 라인의 끝에 있습니다.</li>
        <li>닫힌 중괄호는 그 자신의 마지막 라인에 있습니다. 혹은 (다른 스타일 규칙이 허용된다면) 열린 중 괄호와 같은 라인에 있습니다.</li>
        <li>닫힌 괄호와 열린 중괄호 사이에는 스페이스가 있어야만 합니다.</li>
        <li>모든 파라메터들은 선언과 정의에서 유일한 이름을 가지고 이름지어져 있어야만 합니다.</li>
        <li>모든 파라메터들은 가능하면 정렬되어있어야만 합니다.</li>
        <li>기본 indent는 2개의 스페이스입니다.</li>
        <li>랩(다음 줄에 배치된)된 파라메터는 4개의 스페이스 인덴트를 가집니다.</li>
      </ul>
      <p>만약 일부 파라메터가 사용되지 않는다면 함수 정의에서 변수 이름을 주석 처리하십시오:</p>
      <CODE_SNIPPET>
        // Always have named parameters in interfaces.
        class Shape {
         public:
          virtual void Rotate(double radians) = 0;
        }

        // Always have named parameters in the declaration.
        class Circle : public Shape {
         public:
          virtual void Rotate(double radians);
        }

        // Comment out unused named parameters in definitions.
        void Circle::Rotate(double /*radians*/) {}
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        // Bad - if someone wants to implement later, it's not clear what the
        // variable means.
        void Circle::Rotate(double) {}
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Calls">
    <SUMMARY>된다면 한라인에 모두 넣고, 그렇지 않으면 아규먼트들을 괄호내에서 나누어서 배치합니다.</SUMMARY>
    <BODY>
      <p>함수 호출은 다음과 같은 형식을 가집니다.:</p>
      <CODE_SNIPPET>
        bool retval = DoSomething(argument1, argument2, argument3);
      </CODE_SNIPPET>
      <p>만약 아규먼트들이 한 라인이에 다 들어가지 않는다면, 첫번째 아규먼트의 정렬된 여러 라인으로 나누어져야만 합니다. 열린 괄호 후나 닫힌 괄호 전에 스페이스를 추가하지 마십시오</p>
      <CODE_SNIPPET>
        bool retval = DoSomething(averyveryveryverylongargument1,
                                  argument2, argument3);
      </CODE_SNIPPET>
      <p>함수가 많은 아규먼트들을 가지고 있다면, 코드를 더 읽기 쉽게 한다면 라인당 하나씩 놓는 것을 고려해 보십시오:</p>
      <CODE_SNIPPET>
        bool retval = DoSomething(argument1,
                                  argument2,
                                  argument3,
                                  argument4);
      </CODE_SNIPPET>
      <p>함수의 시그너처가 최대 <a href="#Line_Length">라인 길이</a>내에 들어가지 않을만큼 길다면, 모든 아규먼트들을 다음 라인에 위치시켜야 합니다.:</p>
      <CODE_SNIPPET>
        if (...) {
          ...
          ...
          if (...) {
            DoSomethingThatRequiresALongFunctionName(
                very_long_argument1,  // 4 space indent
                argument2,
                argument3,
                argument4);
          }
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Conditionals">
    <SUMMARY>괄호 안쪽에는 스페이스가 없는 것을 선호하십시오. <code>else</code> 키워드는 새로운 라인을 가집니다.</SUMMARY>
    <BODY>
      <p>기본적인 상태 구문에서 허용되는 두가지 형식이 있습니다. 첫번째는 괄호와 상태 사이에 스페이스를 추가하는 것이고, 나머지는 그렇지 않은 것입니다.</p>
      <p>가장 일반적인 형태는 스페이스가 없는 형태입니다. 어느것도 좋습니다. 하지만 <em>일관성을 유지하십시오.</em>. 파일을 수정한다면, 이미 존재하던 형식을 사용하십시오. 새로운 코드를 작성한다면, 디렉토리나 프로젝트의 다른 파일들이 사용하는 형식을 사용하십시오. 의심이 들고 개인적으로 선호하는게 없다면, 스페이스를 추가하지 마십시오.</p>
      <CODE_SNIPPET>
        if (condition) {  // no spaces inside parentheses
          ...  // 2 space indent.
        } else if (...) {  // The else goes on the same line as the closing brace.
          ...
        } else {
          ...
        }
      </CODE_SNIPPET>
      <p>괄호 사이에 스페이스를 추가하는 것을 선호한다면:</p>
      <CODE_SNIPPET>
        if ( condition ) {  // spaces inside parentheses - rare
          ...  // 2 space indent.
        } else {  // The else goes on the same line as the closing brace.
          ...
        }
      </CODE_SNIPPET>
      <p>모든 경우에 있어서 <code>if</code>와 열린 괄호 사이에는 스페이스가 있어야만 합니다. 또한 닫는 괄호와 중괄호 사이에도 스페이스가 있어야 합니다.</p>
      <BAD_CODE_SNIPPET>
        if(condition)     // Bad - space missing after IF.
        if (condition){   // Bad - space missing before {.
        if(condition){    // Doubly bad.
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        if (condition) {  // Good - proper space after IF and before {.
      </CODE_SNIPPET>
      <p>짧은 조건 구문은 가독성을 증가시킨다면 한 라인에 쓰여질 수 있습니다. 라인이 짧고 <code>else</code> 키워드를 사용하지 않을 때만 이것을 사용할 것입니다.</p>
      <CODE_SNIPPET>
        if (x == kFoo) return new Foo();
        if (x == kBar) return new Bar();
      </CODE_SNIPPET>
      <p>만약 구문에 <code>else</code>가 있다면 이것은 허용되지 않습니다:</p>
      <BAD_CODE_SNIPPET>
        // Not allowed - IF statement on one line when there is an ELSE clause
        if (x) DoThis();
        else DoThat();
      </BAD_CODE_SNIPPET>
      <p>일반적으로, 중괄호는 한 라인의 구문에 대해서는 필요하지 않습니다. 그러나 복잡한 조건을 가지는 조건절이나 루프 구문 혹은 중괄호가 있을 때 가독성이 더 증가하는 구문의 경우에는 중괄호가 허용됩니다. 일부 프로젝트의 경우에는 <CODE>if</CODE>는 항상 중괄호를 가져야만 합니다.</p>
      <CODE_SNIPPET>
        if (condition)
          DoSomething();  // 2 space indent.

        if (condition) {
          DoSomething();  // 2 space indent.
        }
      </CODE_SNIPPET>
      <p>그러나, <code>if</code>-<code>else</code> 구문의 한 부분이 중괄호를 가진다면, 다른 부분도 역시 가져야만 합니다.:</p>
      <BAD_CODE_SNIPPET>
        // Not allowed - curly on IF but not ELSE
        if (condition) {
          foo;
        } else
          bar;

        // Not allowed - curly on ELSE but not IF
        if (condition)
          foo;
        else {
          bar;
        }
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        // Curly braces around both IF and ELSE required because
        // one of the clauses used braces.
        if (condition) {
          foo;
        } else {
          bar;
        }
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Loops and Switch Statements">
    <SUMMARY>Switch 구문은 블럭에 대해서 brace를 사용할 지도 모릅니다. 빈 루프 몸체는 <code>{}</code> 혹은 <code>continue</code>를 사용해야만 합니다.</SUMMARY>
    <BODY>
      <p><code>switch</code> 구문의 <code>case</code> 블럭은 선호하는 것에 따라서 중괄호를 가지거나 가지지 않을 수 있습니다. 만약 중괄호를 사용한다면, 아래에 보여지는 것처럼 사용해야 합니다.</p>
      <p>열거형 값에 대한 조건이 아니면, switch 구문은 <code>default</code> case를 가져야만 합니다. (열거형 값의 경우에는, 컴파일러가 어떤 값이 다루어지지 않으면 경고를 발생시킬 것입니다.) 만약 default case가 절대 실행되지 않는다면, 간단히 <code>assert</code>를 사용하십시오.:</p>
      
      <CODE_SNIPPET>
        switch (var) {
          case 0: {  // 2 space indent
            ...      // 4 space indent
            break;
          }
          case 1: {
            ...
            break;
          }
          default: {
            assert(false);
          }
        }
      </CODE_SNIPPET>
      <p>빈 루프 몸체는 하나의 세미콜론이 아니라, <code>{}</code> 혹은 <code>continue</code>를 사용해야만 합니다.</p>
      <CODE_SNIPPET>
        while (condition) {
          // Repeat test until it returns false.
        }
        for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - empty body.
        while (condition) continue;  // Good - continue indicates no logic.
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        while (condition);  // Bad - looks like part of do/while loop.
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Pointer and Reference Expressions">
    <SUMMARY>점과 화살표 주위에 공백이 없습니다. 포인터 연산자는 여분의 공백을 가지지 않습니다.</SUMMARY>
    <BODY>
      <p>다음은 올바르게 작성된 포인터와 레퍼런스 표현식의 예제들입니다.</p>
      <CODE_SNIPPET>
        x = *p;
        p = &amp;x;
        x = r.y;
        x = r-&gt;y;
      </CODE_SNIPPET>
      <p>다음을 주의하십시오:</p>
      <ul>
        <li>멤버에 접근할 때, 점과 화살표 주위에 어떤 공백도 없습니다.</li>
        <li>포인터 연산자는 <code>*</code> 혹은 <code>&amp;</code> 다음에 어떤 공백도 없습니다.</li>
      </ul>
      <p>포인터 변수나 아규먼트를 선언할 때, 별표를 타입 혹은 변수 이름, 둘 중에 하나쪽에 붙일지도 모릅니다.</p>
      <CODE_SNIPPET>
        // These are fine, space preceding.
        char *c;
        const string &amp;str;

        // These are fine, space following.
        char* c;    // but remember to do "char* c, *d, *e, ...;"!
        const string&amp; str;
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        char * c;  // Bad - spaces on both sides of *
        const string &amp; str;  // Bad - spaces on both sides of &amp;
      </BAD_CODE_SNIPPET>
      <p>하나의 파일 내에서는 일관성을 가지고 이것을 해야만 합니다. 그래서 존재하는 파일을 수정할 때, 파일에서 사용된 스타일을 사용하십시오.</p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Boolean Expressions">
    <SUMMARY><a href="#Line_Length">표준 라인 길이</a>보다 더 긴 boolean 표현식을 가지고 있을 때, 라인의 어디에서 자를지에 대해서 일관성을 유지하십시오.</SUMMARY>
    <BODY>
      <p>이 예제에서, 논리 AND 연산자는 항상 라인의 끝에 옵니다:</p>
      <CODE_SNIPPET>
        if (this_one_thing &gt; this_other_thing &amp;&amp;
            a_third_thing == a_fourth_thing &amp;&amp;
            yet_another &amp;&amp; last_one) {
          ...
        }
      </CODE_SNIPPET>
      <p>
        Note that when the code wraps in this example, both of
        the <code>&amp;&amp;</code> logical AND operators are at the
        end of the line.  This is more common in Google code, though
        wrapping all operators at the beginning of the line is also
        allowed.  Feel free to insert extra parentheses judiciously
        because they can be very helpful in increasing readability
        when used appropriately.  Also note that you should always use the
        punctuation operators, such as <code>&amp;&amp;</code> and
        <code>~</code>, rather than the word operators, such as <code>and</code>
        and <code>compl</code>.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Return Values">
    <SUMMARY>괄호로 <code>return</code> 식을 불필요하게 둘러싸지 마십시오.</SUMMARY>
    <BODY>
      <p><code>x = expr;</code> 형태로 사용되는 곳에서 만, <code>return expr;</code>에 괄호를 사용하십시오.</p>
      <CODE_SNIPPET>
        return result;                  // No parentheses in the simple case.
        return (some_long_condition &amp;&amp;  // Parentheses ok to make a complex
                another_condition);     //     expression more readable.
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        return (value);                // You wouldn't write var = (value);
        return(result);                // return is not a function!
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  

  <STYLEPOINT title="Variable and Array Initialization">
    <SUMMARY><code>=</code> 혹은 <code>()</code> 중에 선택해서 사용하십시오.</SUMMARY>
    <BODY>
      <p><code>=</code>와 <code>()</code> 사이에서 선택할 수 있습니다. 다음은 모든 옳습니다.:</p>
      <CODE_SNIPPET>
        int x = 3;
        int x(3);
        string name("Some Name");
        string name = "Some Name";
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Preprocessor Directives">
    <SUMMARY>전처리기 지시자를 시작하는 hash 마크는 항상 라인의 시작에 있어야만 합니다.</SUMMARY>
    <BODY>
      <p>전처리기 지시자가 인덴트 된 코드의 몸체내에 있을 때도, 전처리기 지시자는 라인의 시작 위치에서 시작해야만 합니다.</p>
      <CODE_SNIPPET>
        // Good - directives at beginning of line
          if (lopsided_score) {
        #if DISASTER_PENDING      // Correct -- Starts at beginning of line
            DropEverything();
        # if NOTIFY               // OK but not required -- Spaces after #
            NotifyClient();
        # endif
        #endif
            BackToNormal();
          }
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        // Bad - indented directives
          if (lopsided_score) {
            #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
            DropEverything();
            #endif                // Wrong!  Do not indent "#endif"
            BackToNormal();
          }
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Class Format">
    <SUMMARY><code>public</code>, <code>protected</code> 그리고 <code>private</code> 순서대로 섹션이 위치합니다. 각각은 하나의 스페이스로 인덴트됩니다.</SUMMARY>
    <BODY>
      <p>클래스 선언의 기본 형태는 다음과 같습니다.(주석은 없습니다, 어떤 주석이 필요한지에 대한 토론에 대해서는 <a HREF="#Class_Comments">클래스 주석들</a>를 보십시오:</p>
      <CODE_SNIPPET>
        class MyClass : public OtherClass {
         public:      // Note the 1 space indent!
          MyClass();  // Regular 2 space indent.
          explicit MyClass(int var);
          ~MyClass() {}

          void SomeFunction();
          void SomeFunctionThatDoesNothing() {
          }

          void set_some_var(int var) { some_var_ = var; }
          int some_var() const { return some_var_; }

         private:
          bool SomeInternalFunction();

          int some_var_;
          int some_other_var_;
          DISALLOW_COPY_AND_ASSIGN(MyClass);
        };
      </CODE_SNIPPET>
      <p>주의해야 할 것</p>
      <ul>
        <li>베이스 클래스 이름은 80 컬럼 제한내에서 파생 클래스 이름과 같은 라인에 있어야만 합니다.</li>
        <li><code>public:</code>, <code>protected:</code>, 그리고 <code>private:</code> 키워드는 하나의 스페이스로 인덴트되어야만 합니다.</li>
        <li>첫번째 인스턴스를 제외하고는, 이 키워드들의 앞에는 공백 라인이 와야합니다. 이 규칙은 작은 클래스에서는 옵션입니다.</li>
        <li>이 키워드뒤에 공백 라인을 남겨두지 마십시오.</li>
        <li><code>public</code> 섹션이 첫번째 입니다. 그리고 <code>protected</code> 마지막에 <code>private</code> 섹션입니다..</li>
        <li>이 각각의 섹션들내의 선언 순서 규칙에 대해서는 <a HREF="#Declaration_Order">선언 순서</a>를 보십시오.</li>
      </ul>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Constructor Initializer Lists">
    <SUMMARY>생성자 초기화 리스트는 모두 한라인에 오거나, 4개의 스페이스로 인덴트된 후에 라인에 올 수 있습니다.</SUMMARY>
    <BODY>
      <p>초기화 리스트에 대해서 두개의 허용되는 포멧이 있습니다:</p>
      <CODE_SNIPPET>
        // When it all fits on one line:
        MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {}
      </CODE_SNIPPET>
      <p>혹은</p>
      <CODE_SNIPPET>
        // When it requires multiple lines, indent 4 spaces, putting the colon on
        // the first initializer line:
        MyClass::MyClass(int var)
            : some_var_(var),             // 4 space indent
              some_other_var_(var + 1) {  // lined up
          ...
          DoSomething();
          ...
        }
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Namespace Formatting">
    <SUMMARY>namespace의 내용들은 indent되지 않습니다.</SUMMARY>
    <BODY>
      <p><a href="#Namespaces">네임스페이스</a>는 여분의 indent를 추가하지 않습니다. 예를 들면, 다음과 같이 사용하십시오:</p>
      <CODE_SNIPPET>
        namespace {

        void foo() {  // Correct.  No extra indentation within namespace.
          ...
        }

        }  // namespace
      </CODE_SNIPPET>
      <p>네임스페이스내에서 indent하지 마십시오:</p>
      <BAD_CODE_SNIPPET>
        namespace {

          // Wrong.  Indented when it should not be.
          void foo() {
            ...
          }

        }  // namespace
      </BAD_CODE_SNIPPET>
      <p>중첩된 네임스페이스를 선언할 때, 각각의 라인에 각 네임스페이스를 넣으십시오.</p>
      <CODE_SNIPPET>
        namespace foo {
        namespace bar {
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Horizontal Whitespace">
    <SUMMARY>위치에 기반해서 수평 공백문자를 사용하십시오. 라인 끝에 존재하는 끌리는 공백문자를 절대로 넣지 마십시오.</SUMMARY>
    <BODY>
      <SUBSECTION title="General">
        <CODE_SNIPPET>
        void f(bool b) {  // Open braces should always have a space before them.
          ...
        int i = 0;  // Semicolons usually have no space before them.
        int x[] = { 0 };  // Spaces inside braces for array initialization are
        int x[] = {0};    // optional.  If you use them, put them on both sides!
        // Spaces around the colon in inheritance and initializer lists.
        class Foo : public Bar {
         public:
          // For inline function implementations, put spaces between the braces
          // and the implementation itself.
          Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
          void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
          ...
        </CODE_SNIPPET>
        <p>여분의 공백을 추가하는 것은 같은 파일을 수정하는 다른 사람이 병합할 때, 존재하는 여분의 공백문자를 제거할 수 있는 것과 같은 여분의 작업을 하도록 만듭니다. 따라서 여분의 공백문자를 만들지 마십시오. 이미 라인을 변경하고 있다면 여분의 공백 문자를 삭제하십시오 혹은 따른 정리 작업에서 여분의 공백문자를 삭제하십시오. (되도록이면 다른 어떤 사람도 그 파일에서 작업하고 있지 않을 때에).</p>
      </SUBSECTION>
      <SUBSECTION title="Loops and Conditionals">
        <CODE_SNIPPET>
        if (b) {          // Space after the keyword in conditions and loops.
        } else {          // Spaces around else.
        }
        while (test) {}   // There is usually no space inside parentheses.
        switch (i) {
        for (int i = 0; i &lt; 5; ++i) {
        switch ( i ) {    // Loops and conditions may have spaces inside
        if ( test ) {     // parentheses, but this is rare.  Be consistent.
        for ( int i = 0; i &lt; 5; ++i ) {
        for ( ; i &lt; 5 ; ++i) {  // For loops always have a space after the
          ...                   // semicolon, and may have a space before the
                                // semicolon.
        for (auto x : counts) {  // Range-based for loops always have a
          ...                    // space before and after the colon.
        }
        switch (i) {
          case 1:         // No space before colon in a switch case.
            ...
          case 2: break;  // Use a space after a colon if there's code after it.
        </CODE_SNIPPET>
      </SUBSECTION>
      <SUBSECTION title="Operators">
        <CODE_SNIPPET>
        x = 0;              // Assignment operators always have spaces around
                            // them.
        x = -5;             // No spaces separating unary operators and their
        ++x;                // arguments.
        if (x &amp;&amp; !y)
          ...
        v = w * x + y / z;  // Binary operators usually have spaces around them,
        v = w*x + y/z;      // but it's okay to remove spaces around factors.
        v = w * (x + z);    // Parentheses should have no spaces inside them.
        </CODE_SNIPPET>
      </SUBSECTION>
      <SUBSECTION title="Templates and Casts">
        <CODE_SNIPPET>
        vector&lt;string&gt; x;           // No spaces inside the angle
        y = static_cast&lt;char*&gt;(x);  // brackets (&lt; and &gt;), before
                                    // &lt;, or between &gt;( in a cast.
        vector&lt;char *&gt; x;           // Spaces between type and pointer are
                                    // okay, but be consistent.
        set&lt;list&lt;string&gt;&gt; x;        // Permitted in C++11 code.
        set&lt;list&lt;string&gt; &gt; x;       // C++03 required a space in &gt; &gt;.
        set&lt; list&lt;string&gt; &gt; x;      // You may optionally use
                                    // symmetric spacing in &lt; &lt;.
        </CODE_SNIPPET>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>


  <STYLEPOINT title="Vertical Whitespace">
    <SUMMARY>수직 공백문자의 사용을 최소화하십시오.</SUMMARY>
    <BODY>
      <p>필요 없으면 빈 줄을 사용하지 말라. 이는 규칙이 아니라 원칙이다. 특히 함수 사이에 빈 줄은 하나 또는 둘보다 많이 두지 말고, 함수를 빈 줄로 시작하지 않으며 함수 마지막에 빈 줄을 두지 않는다. 함수 안에서 빈 줄은 잘 판단해 사용한다.</p>
      <p>기본 원칙은 코드를 한 화면 안에 나오도록 하면 프로그램 제어 흐름을 따라가고 이해하기 더 쉽다는 것이다. 물론 가독성은 너무 밀집해도 반대로 너무 퍼뜨려도 나빠질 수 있으므로 잘 판단해야 한다. 하지만 일반적으로 수직 빈 칸은 최소로 사용한다.</p>
      <p>일부 경험들은 언제 공백 라인이 유용한지를 도와줄 수 있습니다:</p>
      <ul>
        <li>함수의 시작 혹은 끝에 있는 공백 라인은 매우 드물게 가독성을 도와줍니다.</li>
        <li>if-else 블럭내의 공백 라인은 가독성을 도와줄지도 모릅니다.</li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Exceptions to the Rules">
  <p>위에서 설명한 코딩 관례는 필수입니다. 하지만 모든 좋은 규칙이 그렇듯이, 때때로 여기에서 논의하는 것들과 같은 예외를 가지고 있습니다.</p>

  

  <STYLEPOINT title="Existing Non-conformant Code">
    <SUMMARY>이 스타일 가이드를 따르지 않는 코드를 다룰 때, 이 규칙으로부터 빗나갈지도 모릅니다.</SUMMARY>
    <BODY>
      <p>이 안내문에 없는 규칙으로 만든 코드를 변경할 때는 해당 코드의 지역적인 관례를 일관되게 따르기 위해 이 규칙을 벗어날 수 있다. 어떻게 해야 할지 잘 모르겠으면 원저작자나 현재 그 코드를 담당하고 있는 개발자에게 문의한다. 지역적인 일관성을 비롯해 <em>일관성</em>을 기억해야 한다.</p>
    </BODY>
  </STYLEPOINT>

  

  <STYLEPOINT title="Windows Code">
    <SUMMARY>윈도우 프로그래머들은 주로 윈도우 헤더와 다른 Microsoft 코드에서부터 나온 그들만의 코딩 관례들을 만들었습니다. 자신이 만든 코드를 다른 이가 쉽게 이해할 수 있게 하길 원하므로 어느 플랫폼에서든 C++로 만드는 모든 이가 따를 안내문을 만들었다.</SUMMARY>
    <BODY>
      <p>널리 알려진 윈도우 스타일에 익숙하다면, 당신이 잊었을지도 모를 몇개의 가이드 라인을 반복하는 것은 가치가 있는 일입니다.:</p>
      <ul>
        <li>헝가리안 표기법을 사용하지 마십시오 (예를 들면, 정수 <code>iNum</code> 이름짓기). 소스 파일에 대해서 <code>.cc</code> 확장자를 사용하는 것을 포함해서, Google의 이름 짓기 관례를 사용하십시오.</li>
        <li>윈도에서는 <code>DWORD</code>, <code>HANDLE</code> 등과 같이 기본 타입에 많은 동의어를 정의한다. 윈도 API 함수를 호출할 때 이런 타입을 사용하는 것은 전혀 문제 없으며 권장한다. 그렇다고 하더라도 해당 C++ 타입에 가능한 가깝게 유지해야 한다. 예를 들어 <code>LPCTSTR</code> 대신에 <code>const TCHAR *</code>를 사용한다.</li>
        <li>Microsoft Visual C++로 컴파일할 때, 컴파일러의 경고 레벨을 3 혹은 그 이상으로 설정하십시오. 그리고 모든 경고를 에러로 처리하십시오.</li>
        <li><code>#pragma once</code>를 사용하지 마십시오; 대신에 표준 Google include 가드를 사용하십시오. include 가드내의 경로는 프로젝트 트리의 top에 대한 상대경로여야만 합니다.</li>
        <li>사실, 절대적으로 사용해야되는 것이 아니면, <code>#pragma</code>와 <code>__declspec</code> 같은 표준이 아닌 확장을 사용하지 마십시오. <code>__declspec(dllimport)</code>와 <code>__declspec(dllexport)</code>를 사용하는 것은 허용됩니다.; 그러나 <code>DLLIMPORT</code>와 <code>DLLEXPORT</code> 같은 매크로를 사용해서 그것들을 사용해야만 합니다. 그래야 다른 사람이 코드를 공유할 때, 쉽게 확장을 비활성화 시킬 수 있습니다.</li>
      </ul>
      <p>하지만 윈도에서는 종종 어겨야 하는 규칙도 몇 가지 있다.</p>
      <ul>
        <li>일반적으로 <a HREF="#Multiple_Inheritance">다중 구현 상속의 사용을 금지합니다</a>; 하지만 COM과 일부 ATL/WTL 클래스를 사용할 때는 필요하다. COM 또는 ATL/WTL 클래스와 인터페이스를 구현할 때는 다중 구현 상속을 사용할 수 있다.</li>
        <li>비록 코드에 예외를 사용해서는 안 되지만 ATL과 일부 STL, Visual C++에 포함된 코드 등에서는 예외를 상당히 많이 사용한다. ATL을 사용할 때는 <code>_ATL_NO_EXCEPTIONS</code>를 정의해 예외를 비활성화 해야 한다. 또한 STL에서 예외를 비활성화 할 수 있는지 살펴봐야 하고 그렇게 할 수 없을 때 컴파일러에서 예외를 켜는 것은 괜찮다(이는 STL을 컴파일할 때만이며 여전히 예외 처리 코드를 작성해서는 안 된다).</li>
        <li>미리 컴파일한 헤더로 작업하는 일반적인 방법은 각 소스 파일 가장 위에 헤더 파일을 포함하는 것이다. 전형적으로 그 파일 이름은 <code>StdAfx.h</code> 또는 <code>precompile.h</code>이다. 다른 프로젝트와 코드를 쉽게 공유할 수 있도록 이 파일을 명시적으로 포함하지 말고 (<code>precompile.cc</code>에서 포함하는 것은 제외) 자동으로 포함하도록 <code>/FI</code> 컴파일러 옵션을 사용한다.</li>
        <li>일반적으로 <code>resource.h</code>라는 파일 이름을 가지고 있고 단지 매크로들만 가지고 있는 리소스 헤더 파일들은 이 스타일 가이드 라인을 따를 필요가 없습니다.</li>
      </ul>
    </BODY>
  </STYLEPOINT>

  
</CATEGORY>

<PARTING_WORDS>
  <p>상식에 따르고 <em>일관성을 유지하십시오</em>.</p>
  <p>코드를 수정할 때는 주위 내용을 몇 분간 살펴보고 스타일을 결정한다. <code>if</code> 절 주위에서 빈 칸을 사용하면 그렇게 한다. 주석문을 별로 만든 상자로 감쌌으면 마찬가지로 그렇게 한다.</p>
  <p>스타일 안내문에서는 코딩할 때 사용하는 공통 단어를 제시하므로 사람들이 말하는 방법이 아닌 무엇을 말하는지에 집중할 수 있다. 여기서는 전역 스타일 규칙을 제시하므로 사람들은 그 단어를 알 수 있다. 하지만 지역 스타일 또한 중요하다. 만약 기존 코드와 매우 다르게 보이는 코드를 추가하면 그런 단절된 내용 때문에 다른 이가 그 것을 읽을 때 리듬을 깨뜨린다.</p>
  
  <p>자 코드를 작성하는 방법에 대해 충분히 썼다. 코드 그 자체는 훨씬 더 흥미롭다. 즐겨라!</p>
</PARTING_WORDS>

<HR/>

<p align="right">
Revision 3.231
</p>



<address>Benjy Weinberger<br/> Craig Silverstein<br/> Gregory Eitzmann<br/> Mark Mentovai<br/> Tashana Landray</address>

</GUIDE>
